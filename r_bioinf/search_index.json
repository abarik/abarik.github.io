[
["index.html", "R alapok I. - RNS szekvenálási példákkal 1 Bevezetés", " R alapok I. - RNS szekvenálási példákkal Abari Kálmán 2019-09-05 1 Bevezetés Jelen könyv elsődleges célja az R bemutatása kezdő felhasználók számára. A leírtak megértéséhez semmilyen előzetes ismeret nem szükséges. A példák egy részét a bioinformatika területéről vesszük. A könyvben az R 3 6.1-es verziójának Windows platformra szánt változatát használjuk, de a bemutatott parancsok a későbbi verziókban és az egyéb platformokon (Linux, macOS) is ugyanúgy működnek. Örömmel fogadjuk az Olvasóink észrevételeit, amelyeket az abari.kalman@gmail.com címre várjuk. "],
["az-r.html", "1.1 Az R", " 1.1 Az R Az R egy magas szintű programozási nyelv és környezet, amelynek legfontosabb felhasználása az adatelemzés és az ahhoz kapcsolódó grafikus megjelenítés. Az R alapvető használata során parancsokat gépelünk be és hajtunk végre. Ez lényegesen eltér a ma megszokott felhasználói programok világától, ahol egy grafikus felhasználói felületen egérrel vagy az ujjunkkal elmutogatjuk a kívánt tevékenységet. Az R egészen más megközelítést vall, használata a kezdeti lépésektől nagyfokú figyelmet és pontosságot követel. A parancsokban való gondolkodást végig áthatja a tudom mit csinálok elv, így némi idő elteltével érezni fogjuk, hogy az R megszelídül, már nem köt bele minden “mondatunkba”, egyre több dologra tudjuk rávenni, és végül egy rendkívül értékes társsá válik. Jelen könyv ezen az úton szeretné végigvezetni az olvasót. Már a tanulás elején szeretnénk tisztázni, hogy az R elsajátításához nem szükséges programozói alaptudás. Az R felhasználók többsége egyáltalán nem programozó, és a mindennapi adatelemző munka sem igényli az R nyelv programozói fokú ismeretét. Természetesen, ha rendelkezünk ilyen irányú előtanulmányokkal a tanulási folyamat néhány szakasza lerövidíthető, de könyvünk elsősorban azok számra íródott, akik programozási nyelvekkel korábban nem találkoztak, és nem is vágynak az R ilyen mélységű tudására. Az R nyelv elsajátítása során bevezetjük azokat az egyszerű fogalmakat, amelyeket nem nélkülözhetők az adatelemzés során, és egy kitekintő fejezetben összefoglaljuk az R alapvető programozási lehetőségeit is, azonban az R programozásához más szakkönyveket javaslunk olvasásra. Összefoglalva, a könyv azon nem-programozó beállítottságú szakemberek és hallgatók számára kíván gyakorlati segítséget nyújtani, akik a kitűzött elemzési feladatukat az R statisztikai programcsomag segítségével kívánják megoldani. A könyv legelején tisztázni érdemes azt a fontos kérdést is, hogy az R milyen előnyökkel és hátrányokkal rendelkezik. Az R egyik gyengesége, hogy nagy adatbázisok kezeléséhez erős hardverre van szükség, ugyanis az R nem különösebben gyors programozási nyelv, de ez a legtöbb felhasználás során semmilyen problémát nem okoz. A másik gyengeség, hogy az R elsajátításához nem kevés idő és kitartás szükséges. Jelen könyv épp ezt a folyamatot kívánja megkönnyíteni, lerövidíteni. Soroljuk fel azokat az érveket is, amelyek az R mellett szólnak: Az R szabad szoftver, bárki ingyenesen letöltheti és használhatja. Ez egyfelől megkönnyíti az oktatási intézmények, tanszékek és oktatók munkáját, hiszen nincs szükség a kereskedelmi programok licenszeléséből adódó pénzügyi vagy más természetű nehézségek kezelésére. Másrészt a hallgatók a statisztika kurzusok során megtanultakat otthon vagy később a munkájukban is felhasználhatják. Az R platform-független, azaz Windows, Linux és macOS környezetben is használható. Nem kell a kedvenc operációs rendszerünkről lemondani, ha az R-t szeretnénk használni. Az R egy teljes értékű programozási nyelv, nem csak egy statisztikai programcsomag önmagában. Az R statisztikai módszerek szinte végtelen választékát kínálja. A R-ben felhasználható statisztikai eljárásokat statisztikusok fejlesztik folyamatosan és csomagok formájában teszik elérhetővé. Valószínű, hogy egy-egy új statisztikai módszer leghamarabb az R-ben válik elérhetővé. Az R rendkívül gazdag grafikus lehetőségekkel rendelkezik. A statisztikai szakirodalomban és az egyetemi oktatók körében egyre elterjedtebb az R, mint közös (statisztikai program)nyelv használata. Ha a Weben valamilyen statisztikai problémára keressük a megoldást, vagy csak konzultálunk egy statisztikussal, az R ismerete (akár csak “olvasási” szinten) rendkívüli előnyt jelenthet. Az R igen jól dokumentált, a beépített súgón kívül számos könyv és leírás érhető el Weben vagy vásárolható meg üzletekben. A parancssoros interfész számos előnyt jelent. Egyrészt a szkript állományok létrehozása és végrehajtása a statisztikai elemzések megismételhetőségét biztosítják, másrészt az oktatók és a hallgatók könnyebb kommunikációját is lehetővé teszi. Az R az adatelemzés eredményének sokszínű publikálását is biztosítja. Az RMarkdown formanyelven keresztül HTML, PDF és Word dokumentumot, illetve prezentációs diákat vagy akár kész cikkeket hozhatunk létre. A Shiny csomag segítségével interaktív Webes alkalmazásokat építhetünk. Mára az R használata szinte egyet jelent az ingyenesen elérhető RStudio használatával, amely egy kényelmes integrált fejlesztői környezetet (integrated development environment, IDE) biztosít az interaktív adatelemzéshez. "],
["alapelvek-az-r-hasznalatahoz.html", "1.2 Alapelvek az R használatához", " 1.2 Alapelvek az R használatához Mielőtt elkezdjük ezt az izgalmas utat – az R tanulmányozását – néhány alapelvet szeretnék megemlíteni, ami segíthet minket az utazásunk során: Magabiztosság - Az R nagyon nagy, így a teljes a megismerése nem lehet célunk. Mindig lesz valaki, aki az R egyik vagy másik részét jobban, vagy kevésbé ismeri nálunk. Ez természetes, ezen soha ne csodálkozzunk. Az eltérő ismeretek azonban az R speciális területeire vonatkoznak, az alap R tudás (1.3 fejezet) minden R-ben jártas felhasználó számára közös. E könyv célja ennek az alaptudásnak az átadása, melynek birtokában már kellő magabiztossággal vághatunk neki az R azon részeinek az elsajátításába, amely az éppen elénk kerülő speciális feladat megoldásához szükséges. Gyakorlás - Az R alaptudásának megszerzése némi időbe telik, ez tagadhatatlan. Ahhoz, hogy a motivációnk megmaradjon, viszonylag jól kell éreznünk magunkat a tanulás során. Törekedjünk tehát erre! A könyvben ezért minden fejezet végén találunk megoldandó feladatokat, amelyek között reményeink szerint szórakoztatók vagy legalábbis elég érdekesek is szerepelnek. Svájci bicska - A R nagyon sokféle statisztikai és nem-statisztikai probléma megoldására képes, sőt ugyanarra a problémára nagyon sok különböző eszközt kínál. Nem mindig a legszebb, legoptimálisabb megoldás jut először az eszünkbe, de ez a legtöbb esetben nem jelent gondot, elég ha egy megoldást ismerünk. "],
["Ralaptudas.html", "1.3 Az R alaptudás", " 1.3 Az R alaptudás Melyek az R-ben való munkavégzéshez nélkülözhetetlen alapismeretek? Meggyőződésem, ha a lentebb felsorolt témakörökkel tisztában vagyunk, akkor már biztos R tudással rendelkezünk, és bármilyen további R témakör könnyen elsajátítható. Később visszatérhetünk ehhez a listához, és ellenőrizhetjük, hány elemet tudunk kipipálni. Az R alaptudás elemei: Az RStudio alapszintű ismerete. Szükség van egy eszközre, amely biztosítja számunkra az R interpretert és a teljes R környezetet. Az R nyelvet ismernünk kell alapszinten: konstansok írása objektumok kezelése egyszerű adattípusok alapvető operátorok kifejezés fogalma a függvényhívás lehetőségei összetett adattípusok (vektor, faktor, mátrix, adattábla, tibble, lista) a vektoraritmetika szabályai Fontos az alapvető függvények ismerete: csomagkezelő függvények a munkaterület függvényei matematikai függvények input/output függvények indexelés, szűrés, rendezés információ kérés az objektumokról egyszerű típuskonverzió transzformáció a hagyományos grafika és a ggplot2 alapszintű ismerete ismétlő és összesítő függvények Egyéb ismeretek a tagolt szöveges állomány fogalma reprodukálható kutatás az RMarkdown segítségével "],
["a-modern-r.html", "1.4 A modern R", " 1.4 A modern R Az R egy nem túl fiatal, a funkcionális programnyelvekhez hasonlóan építkező programozási nyelv, vagyis egy probléma megoldása tipikusan sokszorosan egymásba ágyazott függvényhívások segítségével történik. Ez sok-sok nyitó és záró kerekzárójellel jár együtt, és így a parancsaink áttekintése és karbantartása nehézségekbe ütközhet. Ezt kiküszöbölendő az R-ben előszeretettel használunk procedurális eszközöket (például for ciklusokat), de a kód olvashatóságát igazán ez sem könnyíti meg. Azonban a 2014-es év az R nyelv életében meghatározó változást hozott, egyrészt megjelent a magrittr csomagban a pipe operátor (%&gt;%), amellyel olvashatóbb kódok írására nyílt lehetőség, másrészt a pipe operátorra alapozva Hadley Wickham bemutatta a dplyr és tidyr csomagokat, amelyek az R funkcionális oldalát erősítették meg12. A modern R alatt lényegében azokat a funkciókat értjük, amelyek a tidyverse gyűjteményben található csomagokhoz kötődnek. Ezekkel a csomagokkal, gyorsabb, olvashatóbb és könnyebben karbantartható kódokat hozhatunk létre. A tidyverse használata tehát erősen javasolt, de ebben a könyvben a “hagyományos” (értsd tidyverse előtti) lehetőségeket is bemutatjuk. Valójában még két egyszerű adattípusról beszélhetünk a complex és row típusokról, amelyekkel komplex számokat és bináris adatokat kezelhetünk. Az adatelemzés során ritkán van ezekre szükség.↩ http://www.unicode.org/charts/↩ "],
["jelolesi-konvenciok.html", "1.5 Jelölési konvenciók", " 1.5 Jelölési konvenciók A könyv szövegében a csomagneveket (például ggplot2) félkövérrel szedjük, a forráskódok és az állománynevek írógépszerű szöveggel jelennek meg (például library(ggplot2) vagy data/movies.csv). Ha függvényekre hívatkozunk, mindig használjuk a kerekzárójeleket (például Desc()). A dupla kettőspont operátor az objektum elérését biztosítja az adott csomagból (DescTools::Desc()). A függvény nevesített argumentumaiban az egyenlőségjelet is szerepeltetjük, például main=. A szöveges részek közötti forráskódok nem tartalmaznak promptot (&gt; vagy + jeleket), az outputként megjelenő sorok pedig két kettőskereszttel (##) kezdődnek. Példaképp, a sessionInfo() függvény hívását és outputját mutatjuk be, amely a könyv írása során használt R környezetről nyújt tájékoztatást. sessionInfo() ## R version 3.6.1 (2019-07-05) ## Platform: x86_64-w64-mingw32/x64 (64-bit) ## Running under: Windows 10 x64 (build 18362) ## ## Matrix products: default ## ## locale: ## [1] LC_COLLATE=Hungarian_Hungary.1250 ## [2] LC_CTYPE=Hungarian_Hungary.1250 ## [3] LC_MONETARY=Hungarian_Hungary.1250 ## [4] LC_NUMERIC=C ## [5] LC_TIME=Hungarian_Hungary.1250 ## ## attached base packages: ## [1] stats graphics grDevices utils datasets ## [6] methods base ## ## loaded via a namespace (and not attached): ## [1] compiler_3.6.1 magrittr_1.5 bookdown_0.12 ## [4] htmltools_0.3.6 tools_3.6.1 rstudioapi_0.10 ## [7] yaml_2.2.0 Rcpp_1.0.2 stringi_1.4.3 ## [10] rmarkdown_1.14 knitr_1.24 stringr_1.4.0 ## [13] xfun_0.8 digest_0.6.20 packrat_0.5.0 ## [16] evaluate_0.14 "],
["alapok.html", "2 Alapok", " 2 Alapok Ebben a fejezetben áttekintjük: az R nyelv, az Alap R, a csomagok és az RStudio megkülönböztetése az R működése, a konzol használata interaktív és parancsállományos használat lényege csomag fogalma Az Olvasó a puszta kíváncsiságon túl vélhetően valamilyen céllal vette kezébe ezt a könyvet, így az R-ről annyit minden bizonnyal tud, hogy egy statisztikai programcsomag, de lehet, hogy ennél pontosabban információi is vannak. Az R egyrészt egy magas szintű programozási nyelv, hamarosan megtanuljuk, hogyan írjunk ezen a nyelven értelmes utasításokat. Másrészt a nyelv körüli környezetet is jelenti, amely magába foglalja a parancsaink értelmezésért felelős R interpretert, valamint azokat a csomagokat, amelyekkel az R tudása kiegészíthető. Érdemes néhány szereplőt és fogalmat tisztázni az R világán belül. "],
["szereplok-es-fogalmak.html", "2.1 Szereplők és fogalmak", " 2.1 Szereplők és fogalmak Az R nyelvet 1992-ben kezdte fejleszteni Ross Ihaka és Robert Gentleman, 1997-től pedig egy nagyobb csapat, az R Development Core Team vezeti a fejlesztést (rövidebben R Core Team). Ettől az évtől az R hivatalosan a GNU projekt része. Az R Core Team tagjai 2002-ben létrehozták a The R Foundation for Statistical Computing (rövidebben The R Foundation) közhasznú, nonprofit szervezetet, amelynek célja (1) az R folyamatos fejlesztésének biztosítása, és ehhez kapcsolódóan a nyílt forráskódú számítógépes statisztikai innovációk támogatása, (2) az R fejlesztői közösség (R Core Team) hivatalos hangjaként a felhasználók, intézmények és üzleti vállalkozások számára a kommunikáció biztosítása, és (3) az R program és dokumentációk szerzői jogainak kezelése. A szervezet rendszeresen konferenciákat, találkozókat szervez, referált folyóiratot, kézikönyveket és technikai leírásokat ad ki, valamint fenntart egy számítógépes infrastruktúrát (CRAN: levelező listákat, FTP és Webszervereket üzemeltet). Az R Foundation hivatalos oldala – egyben az R hivatalos oldala – a https://www.r-project.org/. Az R Foundation (és más önkéntesek) által üzemeltetett számítógépes hálózat neve a CRAN (Comprehensive R Archive Network), amely szabad hozzáférést nyújt az R legfrissebb aktuális verziójához, az R kiterjesztéseihez (a csomagokhoz) és a részletes dokumentációkhoz. A CRAN fő számítógépe Ausztriában található https://CRAN.R-project.org/, azonban nagyon sok naponta frissülő tükör szerver érhető el világszerte (https://cran.r-project.org/mirrors.html). Az eddigiek alapján az lehet a benyomásunk, hogy az R fejlesztője az R Core Team, és a terjesztését a CRAN-on keresztül az R Foundation végzi. Ez részben igaz, de a pontosításhoz tisztáznunk kell, hogy mit is értünk R alatt. Az R, mint programozási nyelv fejlesztője valóban az R Core Team. Az R nyelv egy rendkívül népszerű szkriptnyelv, több millióan használják világszerte. Elsősorban adatelemzésre, adatmodellezésre és grafikus megjelenítésre, vagyis arra, amit ma adattudományok (data science) alatt értünk. Azonban az R nyelv önmagában nem szoftver, hanem egy rendkívül rugalmas szkriptnyelv, amely például előírja, hogy milyen szintaktikai szabályok mentén fogalmazhatjuk meg az utasításinkat. Ahhoz, hogy az R nyelvet használni tudjuk, vagyis, hogy a számítógép valóban végre is hajtsa a szintaktikailag helyes utasításinkat, szükség van egy szoftveres környezetre, egy futtató környezetre, amely tehát a kódunkat értelmezi és végrehajtja. Az R, mint környezet három fő összetevőt összetevőt tartalmaz: (1) egy konzol, ahová a parancsainkat begépelhetjük; (2) a parancsok végrehajtásáért felelős R interpretert; (3) a csomagokat. A konzol és az interpreter biztosítja az R nyelven írt parancsok tényleges végrehajtását. Így tudunk adatokat beolvasni, átlagot számolni, varianciaelemzést futtatni, vagy publikációkész ábrákat létrehozni. A csomagok adatokat és függvényeket tartalmaznak, például a MASS csomag 88 adatobjektumot és 78 függvényt tartalmaz. A függvények valamilyen tevékenységet hajtanak végre, és valójában ezeket a csomag-függvényeket használjuk fel a konzolban, ha bármilyen tevékenységet szeretnénk végrehajtani (például adatokat beolvasni, átlagot számolni stb.). Kb. 17000 csomag érhető el az R-hez. Csomagok 3 csoportját különböztetjük meg: standard csomagok (14 db), ajánlott csomagok (15 db) és egyéb csomagok (kb. 17000 db). A standard csomagok fejlesztője az R Core Team. A standard csomagok: base, compiler, datasets, grDevices, graphics, grid, methods, parallel, splines, stats, stats4, tcltk, tools, utils. Az ajánlott csomagok: KernSmooth, MASS, Matrix, boot, class, cluster, codetools, foreign, lattice, mgcv, nlme, nnet, rpart, spatial, survival. Az ajánlot csomagok közül a foreign és az nlme fejlesztője az R Core Team, a többit más felhasználók fejlesztették, például a már említett MASS csomag fejlesztője Brian Ripley. Csomagot bárki szabadon fejleszthet és terjeszthet, ahogyan ezt nagyon sokan meg is tették. Az egyéb csomagok csoportját akár mi is gyarapíthatjuk. A R környezet már igazi szoftver, terjesztésének koordinálását valóban az R Foundation végzi a CRAN infrastruktúráján keresztül. Ez biztosítja, hogy számítógépünkre telepíthessük az R környezet. Ezt a CRAN-ról elérhető R futtatási környezetet Alap R-nek nevezzük. Fő komponensei a már említett konzol a parancsok begépelésére, R értelmező a begépelt parancsok végrehajtására és a csomagok közül a standard és ajánlott csomagok. Az Alap R telepítése után már tudunk R parancsokat végrehajtani, és nagyon sok adatelemzési probléma megoldására nyílik módunk, sőt azt mondhatjuk, hogy tetszőleges problémát megoldhatunk kisebb-nagyobb erőfeszítéssel, mert az R egy teljes értékű nyelv. Azonban sokszor érdemesebb az egyéb csomagok közül választani, hiszen könnyen elképzelhető, hogy a számtalan csomag között találunk olyat, amely segítségünkre lehet a speciális feladatunk megoldása során. Valószínű, hogy találunk olyan csomagot és benne olyan függvényt, amely adatelemzési, vizuális megjelenítési vagy publikálási feladatunkat jelentősen megkönnyíti. Az egyéb csomagok több tárhelyről érhetők el, ezek közül legjelentősebb az R Foundation által karbantartott CRAN (kb. 15000 csomaggal), a Bioconductor (1741 csomaggal) és a GitHub. Az egyéb csomagok között van egy gyűjtemény, amelyet Tidyverse-nek neveznek. Ez a következő csomagokat jelenti: ggplot2, purrr, tibble, dplyr, tidyr, stringr, readr és forcats. Ezek a csomagok nem egyszerűen új funkciókkal ruházzák fel az Alap R tudását, mint általában az egyéb csomagok. Ezek a csomagok konzisztens módon együttműködnek, és egy új megközelítést hoznak az adatelemzési folyamatok végrehajtásában, a kódok írásában. Rövidebb idő alatt hozhatunk létre könnyebben karbantartható kódokat, és a műveleteink végrehajtása is rendszerint gyorsabb. Amikor ebben a megközelítésben hozzuk létre és hajtjuk végre utasításinakat, akkor azt mondjuk hogy a Tidyverse R-t használjuk. Rövidítést használunk az Alap R (AR), és a Tidyverse R (TR) jelölésére. Sokszor e nélkül is kiderül, hiszen a használt csomag jelzi, hogy AR vagy TR van éppen használatban. A TR azonban nem helyettesíti az AR-t, és csak bizonyos feladatokra használható. A könyvben az AR és TR használatát párhuzamosan vezetjük be. Eddig láttuk, hogy az R használatához szükséges az Alap R telepítése, majd a speciális problémánknak megfelelően kiegészíthetjük az R tudását úgy, hogy telepítünk egyet vagy többet az egyéb csomagok kategóriájából. Választhatjuk akár a Tidyverse csomagjait is telepítésre, ugyanis így lehetőségünk nyílik a Tidyverse R használatára. Utasításaink megfogalmazásának ma ez a legmodernebb módja az R-ben. Azonban magukat az utasításokat továbbra is kötelező az konzolba gépelni? Nem. Az R-hez nagyon sok ingyenes fejlesztői környezet érhető el, amelyek alapvetően a parancsok begépelését egyszerűsítik le, és természetesen ajánlanak más kényelmi funkciókat is. A legnépszerűbb ilyen integrált felhasználói környezet az RStudio. Az R elsődleges célja, hasonlóan más statisztikai programcsomagokhoz, a statisztikai adatelemzés, amelyet most 4 részre bontunk: adatok beolvasása, adatok előkészítése elemzésre, adatelemzés, eredmények publikálása. Az R a fenti 4 tevékenység elvégzését teljes körűen támogatja. A könyv célja ezek bemutatása. Ehhez azonban először a számítógépünkre telepíteni kell az Alap R és az RStudio egy-egy változatát. "],
["telepitesek.html", "2.2 Telepítések", " 2.2 Telepítések Az R kényelmes használatához telepítenünk kell a következő komponenseket (a lenti sorrend javasolt): Alap R RStudio csomagok, köztük a tidyverse csomaggyűjtemény. Ha már rendelkezünk ezekkel a szoftverekkel, akkor időről-időre érdemes a legfrissebb verzióra váltani. Az Alap R évente kb. négyszer frissül, az RStudio háromszor, a csomagokat pedig elegendő az Alap R-rel együtt frissíteni. 2.2.1 Az Alap R telepítése Az Alap R telepítése az operációs rendszerünknek megfelelő csomag letöltésével kezdődik: https://cran.r-project.org/. A Windows felhasználók a “Download R for Windows” linken, majd a “base” linken kattintva jutnak el a letölthető változat linkjéhez: “Download R X.X.X for Windows”. A macOS felhasználók a “Download R for (Mac) OS X” linken kattintva jutnak a letölthető változathoz: “R-X.X.X.pkg”. A weboldalon tanácsokat olvashatunk, ezeket szívleljük meg, különösen a “XQuartz” telepítésére vonatkozó információkat. A linux felhasználók az aktuális R verzió telepítéséhez a “Download R for Linux” linken keresztül jutnak, ahol a megfelelő disztribúció (Debian, Redhat, Suse, Ubuntu) kiválasztása után konkrét információkat kapnak a telepítésről. Az R telepítése tipikusan az alapértelmezetten felajánlott opciók nyugtázását jelenti, a legtöbb esetben nem jelent nehézséget. 2.2.2 Az RStudio telepítése Az RStudio telepítéséhez az operációs rendszerünknek megfelelő telepítőt kell letöltenünk az https://www.rstudio.com/products/rstudio/download/ oldalról. A Desktop változatot töltsük le és telepítsük a számítógépünkre. A telepítés során fogadjuk el az alapértelmezett opciókat. 2.2.3 Csomagok telepítése A csomagok telepítésére az Alap R vagy az RStudio elindítása után van módunk. Érdemes a telepítéseket az RStudio-ból végezni. A csomag tárhelye szerint 3 lehetőséget mutatunk be csomag telepítésére. Az R csomagok hivatalos helye a CRAN (The Comprehensive R Archive Network): https://cran.r-project.org/web/packages/. A CRAN számítógépei tárolják a nyílt forráskódú R nyelv és környezet különböző verzióinak kódjait és dokumentációit, így az összes R csomag forráskódját is. Egy bírálási folyamat után bármely felhasználó csomagja a CRAN-ból is elérhető lehet. Az Alap R vagy az RStudio elindítása után az install.packages() függvénnyel tölthetünk le és telepíthetünk csomagot. install.packages(&quot;csomag_neve&quot;) # csomag telepítése A Bioconductor bioinformatikai csomagok lelőhelye. Az innen elérhető csomagokat a következő parancsokkal telepíthetjük: if (!requireNamespace(&quot;BiocManager&quot;, quietly = TRUE)) install.packages(&quot;BiocManager&quot;) BiocManager::install(&quot;csomag_neve&quot;) A felhasználók a saját fejlesztésű csomagokat rendszerint először a GitHub-on keresztül teszik elérhetővé. Ha ezeket a csomagokat szeretnénk kipróbálni, akkor a következő parancsot kell kiadnunk: devtools::install_github(&quot;felhasznalo_neve/csomag_neve&quot;) "],
["az-elso-lepesek.html", "2.3 Az első lépések", " 2.3 Az első lépések Hogyan tudjuk működésre bírni az R-t? Tegyük fel, hogy van egy adatfeldolgozási problémánk (szeretnénk megtudni például a Csillagok háborúja c. film karaktereinek átlagos testmagasságát). Az R nyelv egy interpretált szkript nyelv, azaz szöveges parancsokat kell begépelnünk az R környezet megfelelő helyére. Az Alap R telepítése és indítása után pontosan egy ilyen környezetbe kerülünk. Nézzük meg hogyan? Az Alap R sikeres telepítése után az R futtatása, az adott platformon a megfelelő bináris állomány elindítását jelenti. Windows operációs rendszerekben az R indítása többnyire az Asztalon lévő R ikon segítségével lehetséges. Így indíthatjuk el az RGui.exe grafikus felhasználói felülettel rendelkező alkalmazást, amelynek legfontosabb része a külön ablakban megjelenő konzol (2.1 ábra). MacOs környezetben indítsuk el az R.app alkalmazást, amely egyetlen konzolt tartalmaz. Linux környezetben az R parancssori futtatásával szintén egy konzolt kapunk. 2.3.1 A konzol használata A konzol tehát az R környezet központi része mindegyik platformon. A konzol működése nagyon egyszerű: egysoros parancsokat gépelünk be a &gt; prompt után, majd Enter-t nyomunk, az R értelmezi és végrehajtja a begépelt parancsot, majd az eredményt itt konzolban meg is jeleníti. Ezt követően egy újabb sor begépelésére van lehetőségünk, Enter után annak az értelmezése következhet, majd az eredmény megjelenítése jön, és így tovább. A 2.1 ábra két parancs begépelése utáni konzol állapotot mutatja meg, a Windows környezetben megjelenő RGui alkalmazásban. ÁBRA 2.1: RGui alkalmazás a konzollal Windows környezetben Próbáljuk ki mi is a konzolt. Bátran gépeljünk be parancsokat! Az R-el végzett munkáink publikálásánál fontos lehet, hogy hogyan hivatkozzunk erre a programra. Az R indítása után a konzolban megjelenő fejrészből ez is kiolvasható, de bármikor mi is kiírathatjuk ezt az információt a konzolba. citation() Fontos lehet, hogy tudjuk a használt R pontos verziószámát. R.Version() A munka során van egy alapértelmezett munkakönyvtárunk, amelynek a helyét a getwd() függvénnyel kérdezhetjük le (munkakönyvtár beállítása a setwd()-vel történik): getwd() A konzol szisztematikus megismerését folytassuk egy egyszerű paranccsal: 1+2 ## [1] 3 A konzolban most is megjelent az eredmény (3), ahogy az összes eddigi parancsunk esetében ezt láthattuk, ha kipróbáltuk őket a saját konzolunkban. Azonban nem minden parancs ad választ az R-ben. x &lt;- 0 # Nincs válasz a konzolban Sőt, az is előfordulhat, hogy az R nem talált valamit „rendben” a parancsban. Ekkor természetesen nem hajtja/hajthatja végre a begépelt sort, helyette hibát (error) jelez. Ez nem lesz jó. A válasz az Error: unexpected symbol in \"Ez nem\" hibaüzenet. Alapvető szabály, hogy ha a válaszban megjelenik az Error: szócska, akkor a parancsunkat valamilyen ok miatt nem tudta végrehajtani az R értelmező, és az Error: utáni részből tájékozódhatunk a hiba okáról. Minden más esetben sikeres volt a végrehajtás. Hosszabb, bonyolult parancsok gépelésénél gyakran előfordul, hogy valamiért nem sikerül „teljessé” tenni a begépelt parancsot, valami még hiányzik belőle (például egy záró kerek zárójel). Ezt az R értelmező észreveszi és az Enter megnyomása után egy + folytatás prompt megjelenítésével jelzi ezt számunkra. A + prompt után van lehetőségünk a hiányzó részek pótlására, majd ha készen vagyunk az Enter billentyűvel az összes eddig még végre nem hajtott sort elküldhetjük az értelmezőnek. Gépeljük be a következő parancsot, három egymás utáni sorba. paste(&quot;Ez már&quot;, &quot;jó&quot; ) ## [1] &quot;Ez már jó&quot; A paste(\"Ez már\", kerüljön az első sorba, majd nyomjunk Enter-t. Az R nem hajtja végre a sort, de erre a nyilvánvalóan hibás, befejezetlen parancsra hibaüzenetet sem jelenít meg. Helyette felajánlja a parancs folytatását, befejezését egy új sorba, amely már a + prompttal kezdődik. (Ez a fenti példában nem jelenik meg, csak a saját konzolunkban láthatjuk.) A második sorba gépeljük be az \"egy\" parancsot, nyomjuk meg az Enter-t. Sajnos még ez sem tette teljessé a parancsunkat, így további folytatásra van lehetőségünk a + után a harmadik sorban. Ide gépeljük be a hiányzó ) részt, és üssünk Enter-t. A parancsunk teljessé vált, megkapjuk az eredményt a konzolban, pont úgy, mintha a három sort egyetlen sorba gépeltük volna. Legyünk nagyon óvatosak a konzol folytatás prompt funkciójával. Ha például az R nem találja a parancs hiányzó részét, akkor a konzol ezen kényelmi funkciója oda vezethet, hogy örökké + promptot kapjuk az Enter megnyomása után. Ezt a helyzetet hivatott megoldani az ESC billentyű, mellyel megszakíthatjuk az értelmező parancsfeldolgozási kísérletét erre a parancsra nézve. Az ESC megnyomása után visszakapjuk a &gt; prompttal kezdődő (üres) sort, vagyis tiszta lappal, új, lehetőség szerint teljes parancs gépelésébe kezdhetünk. A parancssorba mindig teljes parancsot gépeljünk, amint megjelenik a + folytatás prompt, azonnal szakítsuk meg ESC megnyomásával az értelmezési folyamatot. Az R konzolos használatát két funkció valóban kényelmesebbé teszi. Egyrészt a korábban végrehajtott parancsainkat (history, parancsok története) visszahívhatjuk, lapozhatunk bennük előre, hátra. Erre a FEL/LE NYÍL billentyűkkel van lehetőségünk. Természetesen az így visszahívott parancsot tetszőleges módon átszerkeszthetjük: navigálhatunk a sorban előre hátra, beszúrhatunk/törölhetünk karaktereket vagy használhatjuk a vágóasztal billentyűparancsait. A visszahívott és módosított parancsot az Enter segítségével újra végrehajthatjuk, és ehhez még a sor végére sem kell a szövegkurzort pozícionálni, az a sorban tetszőleges helyen állhat, az R mégis a teljes sort fogja értelmezni. A másik kényelmi lehetőség a TAB billentyű használata, amellyel az elkezdett, még be nem fejezett sorokat egészíthetjük ki. Ha egy sort többféleképpen is kiegészíthet az R, akkor egy listát kapunk a lehetőségekről, amelyet továbbgépeléssel szűkíthetünk, ha pedig csak egyetlen szóba jöhető befejezése van a begépelt karaktereknek, akkor a TAB megnyomása után ezzel a résszel kiegészül az elkezdett sorunk. Így nemcsak egyszerűen gépelést, illetve időt takaríthatunk meg, hanem például tájékozódhatunk a korábban létrehozott objektumok nevéről vagy az elérhető függvények névéről és paramétereiről is. Az objektum, a függvények és az egyéb ebben a fejezetben homályosan hagyott fogalmak definícióit a könyv későbbi részeiben részletesen tárgyaljuk. 2.3.2 Parancsállományok Láthattuk, hogy a konzolba egyszerre csak egy parancsot gépelhetünk be, úgy is gondolhatunk rá, mint egy egysoros szövegszerkesztőre. Begépelünk egy sort és végrehajtjuk az Enter-rel. A problémáink többsége viszont nem oldható meg egyetlen paranccsal (csak több tízzel vagy százzal), ezért ez interaktív (vagy konzolos) használat nem alkalmas hosszabb elemzésre. Parancsainkat begépelhetjük egy parancsállományba is, amely egy egyszerű, formázás nélküli szöveges állomány .R kiterjesztéssel. Ezt a szöveges állományt tetszőleges szövegszerkesztővel létrehozhatjuk, minden operációs rendszeren találunk jegyzettömbszerű, formázás nélküli szöveges állományok létrehozására alkalmas szövegszerkesztőt. Egyszerűen begépeljük külön sorokba a konzolba szánt parancsainkat és elmentjük .R kiterjesztéssel. Kész is a parancsállomány vagy más néven szkriptállomány. Parancsállományok létrehozását az Alap R Windows platformos változata közvetlenül is támogatja. Az RGui-ban találunk menüpontokat (File/New script, File/Open script... és File/Save), amelyekkel létrehozhatunk parancsállományokat, már létező szkriptállományt megnyithatunk, és szerkesztés után elmenthetünk. A parancsállományok használata lényegesen leegyszerűsíti az adatelemzés folyamatát, hiszen a konzol egysoros szövegszerkesztője helyett egy gyakorlatilag végtelen sok sor vagy parancs begépelésére alkalmas szövegszerkesztő áll rendelkezésünkre. Mint minden szövegszerkesztőben, a különböző billentyűparancsok és a vágóasztal megkönnyíti a több tíz vagy akár több száz sornyi parancs begépelését és tetszőleges szerkesztését. Az Enter jelentése parancsállományos környezetben a szövegszerkesztőkben megszokott újsor beszúrása, ami lényegesen különbözik a konzolos használat parancsvégrahjatási funkciójától. Ezért ha parancsainkat továbbra is szeretnénk interaktívan végrehajtani, akkor a megfelelő környezetben meg kell találnunk a speciális menüpont vagy billentyűparancsot. Az RGui-ban ez az Edit/Run line or selection vagy az Edit/Run all menüpontokkal, vagy a Ctrl+R billentyűkombinációval lehetséges, amelynek kiadása az első menüpont funkciójának felel meg. Próbáljuk ki a parancsállományok használatát a Windows platformos RGui segítségével. Nyissunk egy új parancsállományt a File/New script menüponttal, és írjuk bele a következő sorokat: # Első parancsállomány 1+23 getwd() # munkakönyvtár kiírása mean(1:100) cat(&quot;- Vége -\\n&quot;) A fenti 5 sor begépelése után mentsük el a parancsállományunkat a File/Save menüpont, vagy a Ctrl+S segítségével elso.R néven az alapértelmezés szerint felajánlott könyvtárba. Ezt az állományt később meg tudjuk nyitni a File/Open script... menüponttal. Most azonban hajtsuk végre soronként. A álljunk a szövegkurzorral az első sorba (bármelyik pozíció jó a soron belül), majd egyesével adjunk ki öt Ctrl+R billentyűparancsot. Mindegyik esetben 3 dolog történik: (1) az aktuális sor átkerül a konzolba, (2) a konzol végrehajtja a parancsot és (3) a szövegkurzor egy sorral lejjebb lép, így egy újabb Ctrl+R már a következő sort hajtja végre. Látható, hogy parancsaink a szkriptállományból mégis a konzolba tudjuk küldeni végrehajtásra. Valami hasonlót kell látnunk a konzolban: &gt; # Első parancsállomány &gt; 1+23 [1] 24 &gt; getwd() # munkakönyvtár kiírása [1] &quot;C:/Users/Kali2/Documents&quot; &gt; mean(1:100) [1] 50.5 &gt; cat(&quot;- Vége -\\n&quot;) - Vége - &gt; A soronkénti végrehajtás mellett nagyon gyakori a kijelölt szövegrészek végrehajtása, amit szintén a Ctrl+R-rel tudunk kezdeményezni. A kijelölt rész lehet több sor, a teljes parancsállomány, vagy valamelyik sor egy része. Ez utóbbi próbáljuk ki úgy, hogy a parancsállomány 2. sorában csak az 1+2 részt jelöljük ki, és hajtsuk végre a Ctrl+R segítségével. Az eredmény a konzolban a 3 lesz. A parancsállományok használatát a következő részben ismertetendő RStudio kapcsán részletesebben bemutatjuk, így a Linux és macOs felhasználók is hamarosan kipróbálhatják a parancsállományos használat előnyeit. 2.3.3 Parancsállományok futtatása A parancsaink összegyűjtése és hosszú távú tárolása sok előnnyel jár a korábban megismert konzolos használathoz képest. Azonban a parancsállományaink sorait nem kizárólag interaktívan hajthatjuk végre, hanem kötegelt felhasználásra is mód van. Ez azt jelenti, hogy vagy az R konzolon belül vagy akár az Alap R eddig nem említett programja segítségével a parancsállomány összes sorát egyszerre végrehajthatjuk. A source() paranccsal az elso.R összes sorát végrehajthatjuk a konzolban. source(&quot;elso.R&quot;, echo = T) A source() függvény kicsit másként közelít a parancsainkhoz, mint amit megszoktunk az interaktív konzolos és parancsállományos használat során. A source() a teljes állományban ellenőrzi a parancsok szintaktikai helyességét, és csak akkor kezdi el az első majd az azt követő parancsok végrehajtásához, ha mindent rendben talált. Parancsállomány kötegelt futtatására az operációs rendszer parancssorából is van lehetőségünk, ehhez az Alap R telepítése után van lehetőségünk, de nem kell elindítanunk az R konzolt tartalmazó alkalmazást. Rscript --vanilla elso.R &gt; output.txt "],
["az-rstudio.html", "2.4 Az RStudio", " 2.4 Az RStudio Az előző fejezetben megismerkedtünk az Alap R-ben elérhető konzol alkalmazással, a parancsállományok fogalmával és parancsállományok futtatási lehetőségeivel. A sikeresen telepített RStudio-ban ezekre és még nagyon sok más tevékenység elvégzésére van módunk. Fontos tisztázni, hogy az RStudio használatához feltétlenül szükség van a telepített Alap R-re, nélküle nem tudunk R parancsokat futtani. Jó gyakorlat, hogy első esetben az RStudio telepítése előtt telepítjük fel az Alap R-et, de a fordított sorrend sem okoz problémát. Sőt, ha az Alap R egy új verzióját telepítjük fel, akkor a korábban telepített RStudio már az új verziójú R futtató környezet fogja használni. Az RStudio tudása tehát a végrhajtható R parancsok tekintetében megegyezik az Alap R tudásával, hiszen minden utasítás, aminek a végrehajtását az RStudio-ban kezdeményezzük, végső soron az Alap R-rel telepített futtató környezethez kerül, és a végrehajtásáért ő felel. Az RStudio elsősorban a parancsok írását könnyíti meg, segítségével a parancsállományok létrehozásához kapunk rendkívüli segítséget. Megjegyezzük, hogy az RStudio egy üzleti vállakozás neve is egyben, amely többféle terméket fejleszt. Ezek egyike az RStudio-nak nevezett integrált fejlesztőkörnyezet, kimondottan az R programozási nyelv számára. Foglaljuk össze, hogy melyek az RStudio erősségei: Parancsok írásának megkönnyítése: kódkiegészítés, szintaxisnak megfelelő kódszínezés, tippek megjelenítése. Intergrált környezetvben egy felületen látjuk a munka során szükséges komponenseket: kód, adatbázis, ábrák, súgó, objektumok és állományok. Projektek használata: az adatfeldolgozási folyamat összetevőit (adatállományok, szkriptállományok, képállományok) egy könyvtárban tartjuk, és a kódból relatívan hivatkozunk rájuk. Publikálás támogatása: RMarkdown segítségével PDF, HTML és Word dokumentum, valamint PDF, HTML és PowerPoint bemutató kényelmes létrehozása. További lehetőségek: Shiny Webes alkalmazás fejlesztésének támogatása; új csomag létrehozásának támogatása; a Git verziókezelő támogatása. Az RStudio fenti lehetőségeinek bemutatása külön könyvet igényelne, de a mindennapi munkához szükséges ismereteket itt bemutatjuk. Már most előrebocsátjuk, minden esetben hozzunk létre projektet az adatfeldolgozási problémánkhoz, és lehetőleg RMarkdown állományt használjunk. 2.4.1 Panelek Az RStudio indítása után egy 4 panelból álló alkalmazást látunk, a paneleken különböző lapok helyezkednek el. A panelek szélessége és magassága állítható, egyrészt az elválasztó sávokat mozgathatjuk az egér segítségével, másrészt a panelek méretező gombjain (az egyes panelek jobb felső sarkában) is kattinthatunk. A méretezés során időlegesen eltűnhetnek panelek, de a sávok mozgatásával vagy a View / Panes / Show All Panes menüponttal láthatóvá tehetjük az összes panelt. A legtöbb időt a Source nevű bal felső panelben töltjük, mert alapértelmezetten itt jelennek meg a parancsállományok és az adatbázisok lapjai. Az RStudio első indításánál ez a panel üres, de a további indításoknál a korábban szerkesztett, de be nem zárt parancsállományok és adatbázisok lapjai automatikusan megjelennek. Helyezzünk el egy parancsállomány lapot a File / New file / New R Script segítségével, és győződjünk meg, hogy egy egyszerű szövegszerkesztőben vagyunk! A bal alsó panel a Console nevet viseli, vagyis ez az RStudio konzolja, melynek használata megegyezik az Alap R konzoljával. Parancsokat gépelünk, és ENTER-rel végrehajtjuk őket. A parancsaink eredménye is itt jelenik meg. A két jobboldali panel többfunkciós. A jobb felső panelben jellenek meg a munka során létrehozott objektumok nevei (Environment lap), valamint a parancsok története (History lap). Az Environment lapon megjelenő adatbázis nevén kattintva a Source panelben egy külön lapon megjelenik az adatbázis tartalma. A jobb alsó panel tartalmazza a súgót (Help lap), a munka során rajzolt ábráinkat (Plot lap), a csomagjainkat (Packages lap) és a munkakönyvtárunk állományait, könyvtárait (Files lap). 2.4.2 Munka az RStudio-ban Mielőtt elkezdjük a munkát az RStudio-ban végezzünk el néhány beállítást. Az RStudio működését az Tools / Global Options... menüpont alatt módosíthatjuk. A menüpont kiválasztása után a bal oldali listából a Code, majd a fenti opciók közül a Saving opciót válasszuk. Itt a Default text encoding alatt érjük el, hogy az UTF-8 legyen kiválasztva. Fontos, hogy minden szöveges állományunk UTF-8 kódolású legyen. (A panelek tartalmán is változtathatunk a Tools / Global Options / Pane Layout menüpontban.) Kezdjük a munkát! Nyissunk egy új parancsállományt (File / New file / New R Script) és gépeljünk be néhány sort: # Második parancsállomány 1+23 getwd() # munkakönyvtár kiírása x &lt;- mean(1:100) plot(1:10) ?mean cat(&quot;- Vége -\\n&quot;) A szövekurzorral álljunk az első sorra, és hajtsuk végre Ctrl+Enter (Windows és Linux alatt, Command+Enter macOS alatt) billentyűparanccsal. Az eredmény nagyon hasonló a korábban látott RGui-s példához, vagyis átkerül a konzolba a sor, az RStudio végrehajtja, és szövegkurzor lejjebb lép egy sorral. Egy újabb Ctrl+Enter így a következő sort hatja végre, és így tovább. Egyetlen kivétel, hogy az RStudio az első valóban R parancsot tartalmazó sorra ugrik a Ctrl+Enter megnyomásakor, tehát a megjegyzést tartalmazó első sort átogorja, és rögtön a második sorral kezdi a végrehajtást. A parancsok végrehajtása során láthatjuk mennyire kényelmes, intergált környezetbe találtuk magunkat. Az x &lt;- mean(1:100) hatására az Environment lapon megjelent az x objektum neve és értéke. A Plot lapon láthatunk egy ábrát, amit a plot(1:10) rajzolt meg, és a ?mean a Help lapon mutatja meg a mean() átlagszámoló függvény beépített súgóját. Mentsük el parancsállományunkat a File / Save vagy a Ctrl+S segítségével. 2.4.3 Projektek használata Az RStudio lehetőséget ad, hogy minden egyes adafeldolgozási feladatunkhoz egy projektet rendeljünk. Egy projekt minimálisan egy projektkönyvtárat és az ebben lévő lévő .Rproj kiterjesztésű projektállományt jelenti. Projekt létrehozása a File / New Project... menüponttal lehetséges. Első lépésként válasszuk a New Directory opciót, majd a New Project nyomógombon kattintsunk. A Directory name szöveges mezőbe a projektünk nevét határozhatjuk meg, ami egyben a projektkönyvtár neve is lesz. Adjuk meg az elso_projekt nevet. A Create project as subdirectory of mezőben azt a szülőkönyvtárat határozhatjuk meg, ahová a projekkönyvtárunkat el szertnénk helyezni. A projekt létrehozását a Create Project nyomógombbal kezdeményezhetjük. Két nagyon fontos dolog történt. Egyrészt a számítógépünkön létrejött az elso_project projektkönyvtár, és benne az elso_projekt.Rproj projektállomány, márészt az RStudio ún. projekt üzzemmódba került, azaz az elso_projekt lett az aktív projekt. Az RStudio-ban egyszerre egy projekt lehet aktív, de lehet, hogy egyetlen projekt sincs megnyitva. Az RStudio felületén a jobb felső sarokban tájékozódhatunk, most az elso_project feliratot látjuk, de amennyiben nincs aktív projektünk, akkor a Project: (none) feliratot olvashatjuk. Minden adafeldolgozási feladathoz – még a legkisebbhez is – hozzunk létre projektet. Minden állományt, amely a feladathoz tartozik a projektkönyvtáron belül helyezzünk el. Milyen állományok jöhetnek szóba: parancsállományok, adatállományok, képállományok, dokumentációk stb. Érdemes ezeket rendezetten, ha szükséges alkönyvtárakba szétosztva tárolni. Jó gyakorlat lehet, hogy a parancsállományokat közvetlenül a projektkönyvtárban (most elso_projekt), az adatállományokat egy data alkönyvtárban a projektkönyvtáron belül (most elso_projekt/data), a képállományok és dokumentációk helye pedig lehet az elso_project/image, illetve elso_projekt/docs. Ha egy másik projektre akarunk váltani az RStudio-ban, akkor zárjuk be az aktív projektet (File / Close project). Később újra megnyithatjuk a File / Open Project... segítségével. A megnyitás során természetesen az .Rproj kiterjesztésű projektállományt kell használnunk. Foglaljuk össze, milyen előnyökkel jár a projekt használata: Fizikailag is együtt tartjuk azokat az állományokat, amelyek logikailag egy adatfeldolgozási folyamathoz tartoznak. Projekt üzemmódban az RStudio az aktuális könyvtárat a projektkönyvtárra állítja, így relatív hivatkozást használhatunk a kódunkban, amely a projekt hordozhatóságát biztosítja különböző számítógépek között. Projektünk fejlesztését a Git verziókezelő segítségével követhetjük nyomon. 2.4.4 Az RMarkdown használata Ahogyan korábban megbeszéltük, a parancsállományok .R kiterjesztésű szöveges állományok, amelyek R parancsokat vagy # kettőskereszttel kezdődő megjegyzés sorokat tartalmaz. Az RStudio azonban egy másik lehetőséget is ad az R kódok és a természetes nyelvű szövegek integráltabb tárolására, ez az RMarkdown állományformátum. Hozzunk létre egy RMarkdown állományt a File / New File / R Mardown... menüpont segítségével. A dialógusdobozban felkínált opciókat fogadjuk el. A Source panelben egy alapértelmezett tartalommal kitöltött RMarkdown állományt látunk. Az RMarkdown állományok .Rmd kiterjesztésű, egyszerű szöveges állományok. A szerkezetére nézve, a következő szabályokat kell betartanunk: Minden RMarkdown állomány egy fejrésszel kezdődik, amit a --- sorok határolnak. Az állományban a fejrész után bárhol elhelyezhetünk természetes nyelvű szöveget A természetes nyelvű szövegek között, bárhol, R parancsok is elhelyezhetők, de azokat speciális határolók közé, ún. R csonkokba kell írnunk. Az RMarkdown fejléce az állomány metaadatait írja le YAML formátumban. --- title: &quot;Untitled&quot; author: &quot;Abari Kálmán&quot; date: &#39;2019 09 02 &#39; output: html_document --- A fejléc a dokumentum címét, szerzőjét és létrehozási időpontját és a kimeneti formátumot tartalmazza, az első három adatot szerkesszük át a saját dokumentumunkban. További információt a fejléc lehetséges beállításáiról itt találunk: HTML dokumentumokhoz, PDF dokumentumokhoz. A természetes nyelvú szövegben – mint említettük – a Markdown szabályai szerint tudunk formázási parancsokat elhelyezni. A formázási lehetőségeről itt tájékozódhatunk: R Markdown Cheatsheet Egy R csonk speciális kezdő és záró sorral rendelkezik. Egy tipikus R csonkot az R parancsokkal a következő kódrészlet mutat be: ```{r chunk-label, echo = FALSE, fig.cap = &#39;A figure caption.&#39;} 1 + 1 rnorm(10) # 10 random numbers plot(dist ~ speed, cars) # a scatterplot ``` A nyitó és zárórész közé egy vagy több R parancsot írhatunk, de akár megjegyzéseket is használhatunk. Az R csonkok részletes leírását az RStudio hivatalos oldalán találjuk: https://rmarkdown.rstudio.com/. Egy rövid tutorial összefoglalja a legfontosabb tudnivalókat. Első pillanatra úgy látszik, hogy az RMarkdown dokumentum egy fordított parancsállomány, hiszen az RMarkdown állományban a természetes nyelvű szöveg írásában teljes szabadságunk van, és ha R kódot akarunk írni, akkor külön, csonkok megadásával gondoskodunk róla (emlékezzünk parancsállományban az R kód elhelyezésében van szabadságunk, a természetes nyelvű szöveget kellett védenünk a # jellel). Valójában miben áll az RMarkdown ereje: A természetes nyelvű szövegekben használhatunk formázást a Markdown formanyelv szabályai szerint. Az RMarkdown állományokat le tudjuk fordítani (Knit-elni), amelynek az eredménye például PDF, HTML, Word vagy PowerPoint állomány lehet, amelyben a természetes nyelvű szövegben a Markdown formázásai érvényesülnek, valamint az R parancsok és a parancsok szöveges és grafikus eredménye is megjelenik. Próbáljuk ki a Knit gombbal a fordítást! Módosítsuk az állomány különböző részeit és fordítsuk újra a dokumentumot. 2.4.5 Billenytűparancsok Az RStudio legfontosabb billentyűparancsa Ctrl+Enter, amely a parancsállomány parancsait a konzolba küldi végrehajtásra. Van még néhány további parancs, amelyet érdemes ismerni: Ctrl+S: Parancsállomány mentése Ctrl+F: Szöveg keresése és cseréje Tab: kód kiegészítése Ctrl+Shift+C: Sorok kommentelése és a kommentelés megszüntetése Ctrl+Alt+Fel vagy Le (és Shift+Jobbra vagy Balra): a kurzor magasságának állítása (és az oszlopszélesség beállítása) több sor szerkesztésére Alt+Fel vagy Le: Sor mozgatása fel vagy le Alt+Shift+K: Billentyűparancsok módosítása Alt+-: Értékadó operátor (&lt;-) beszúrása Ctrl+Shift+M: Pipe operátor (%&gt;%) beszúrása Ctrl+Alt+R: a teljes parancsállomány futtatása Ctrl++ vagy -: betűméret nagyítása vagy kicsinyítése Ha valamelyik kombináció nem működik a számítógépünkön, akkor a Tools / Modify Keyboard Shortcuts... menüpont alatt új billentyűparancsot az adhatunk az egyes funkciókhoz. "],
["segitseg-az-r-hasznalatahoz.html", "2.5 Segítség az R használatához", " 2.5 Segítség az R használatához Az R használatához számos segítséget találunk az Interneten és a telepített Alap R-ben és RStudio-ban egyaránt. Az online segítségek közül elsősorban a http://cran.r-project.org címen olvasható R dokumentációkat emeljük ki, ahol több tucat, elsősorban angol nyelvű leírást találunk az R megismeréséhez. Az R népszerűségének köszönhetően, nagyon sok további dokumentációt, tutoriált és példát találhatunk, ha az internetes keresőkhöz fordulunk. Az R környezetben további lehetőségek állnak rendelkezésre. Az R megismerését kezdhetjük a help.start() paranccsal, ahol számos, az R nyelvet részletesen tárgyaló dokumentum közül választhatunk. Ha csak egyetlen függvénnyel kapcsolatban szeretnénk segítséget kérni, akkor használhatjuk a beépített súgórendszer parancsait. Adjuk ki a help(t.test) vagy a rövidebb ?t.test parancsot, ha a t.test() függvényről szeretnénk részletes leírását kapni. Abban az esetben ha nem ismerjük teljesen a függvény nevét, használhatjuk a help.search(&quot;test&quot;) parancsot, ekkor az összes olyan függvényt kilistázhatjuk, amelynek a nevében vagy a leírásában a “test” karaktersorozat előfordul. Hasznos lehet továbbá a find() parancs, amely elárulja, hogy az illető függvény melyik már betöltött csomagban foglal helyet. find(&quot;aov&quot;) ## [1] &quot;package:stats&quot; A fenti példából kiolvasható, hogy az aov() függvény a stats csomagban található. Ugyancsak a betöltött csomagokban végez keresést az apropos() függvény, amellyel lehetőség van a parancssorból elérhető függvények vagy objektumok nevében keresni. apropos(&quot;aov&quot;) Tovább segítheti az egyes függvények használatának elsajátítását az example() parancs, amely az egyes függvények használatára mutat példát. example(t.test) Utolsó lehetőségként ejtsünk szót a demo() függvényről, amellyel olyan beépített szkripteket futtathatunk, amelyek az R tudását, erejét hivatottak demonstrálni. Próbáljuk ki a demo(graphics) demo(persp) demo(plotmath) demo(Hershey) Ajánljuk tanulmányozásra a R hivatalos oldalát is az elérhető segítségekről: https://www.r-project.org/help.html. Rendkívül népszerűek ma az ún. cheat-sheet-ek, amelyek néhány PDF oldalon sok ábrával, és a lényeg kiemelésével mutatják ba egy-egy témakör legfontosabb tudnivalóit: https://www.rstudio.com/resources/cheatsheets/. "],
["feladatok.html", "2.6 Feladatok", " 2.6 Feladatok Nézzünk utána, hogy ma kb. hány csomag érhető el az R-hez? Keressünk ábrát, amely bemutatja, hogy az évek során hány csomag volt elérhető az R-hez? Mi most az R legfrissebb változata, és milyen újdonságokat tartalmaz az előző változathoz képest? Mi az RStudio legrissebb változata, és milyen újdonságokat tartalmaz az előző változathoz képest? Hol áll az R népszerűsége a többi programozási nyelvhez, illetve statisztikai programcsomaghoz képest? Milyen ingyenesen elérhető, grafikus felhasználói felülettel rendelkező statisztikai programcsomagok építenek az R-re? Keressünk rá, hogy az R számára milyen módon érhetők el a Csillagok háborúja c. film karaktereinek testmagassága? Derítsük ki, hogy az R Core Team vagy Hadley Wickham több R csomag szerzője! Ki az a Hadley Wickham? Hogyan deríthető ki, hogy egy csomagban (például a MASS) csomagban, hány adatobjektum, és hány függvény található? A közösségi médiában melyek az R legfontosabb fórumai? "],
["adatobjektumok.html", "3 Adatobjektumok", " 3 Adatobjektumok Ebben a fejezetben áttekintjük: egyszerű számolási lehetőségek R-ben operátorok használata és a kifejezés fogalmának bevezetése objektum létrehozása és elnevezése több parancs elhelyezése egy sorban megjegyzések használata Az előző fejezetben megismertük azt a környezetet, amelyben lehetőségünk van R parancsok gépelésére és végrehajtására. Tudjuk, legkényelmesebb, ha az RStudio-ban parancsállományt (.R kiterjesztésű állományt) vagy RMarkdown állományt (.Rmd) használunk, de ritkább esetekben az Alap R konzolját vagy a Windows-os környezet RGui alkalmazásának parancsállományát is használhatjuk parancsok írására. Ebben a fejezetben az R nyelvre koncentrálunk, arra, hogy mit írunk, és nem arra, hogy hová írjuk a parancsot. A fenti lehetőségek bármelyike megfelelő lehet a fejezet példainak kipróbálására. Ne felejtsük, hogy a különböző környezetekben eltérő módszerekkel hajthatjuk végre a parancsokat (Enter a konzolban, Ctrl+R az RGui-ban, és Ctrl+Enter az RStudio-ban), továbbá, ha a parancsok végrehajtása közben a + folytatás prompt jelenik meg a konzolban, akkor az Esc billentyűvel tudunk kilépni a befejezetlen sor értelmezéséből. Az R nyelv megismerését számadatok írásával kezdjük. "],
["szamolas-az-r-ben.html", "3.1 Számolás az R-ben", " 3.1 Számolás az R-ben Kezdjük az R nyelv megismerését egy egyszerű sor begépelésével. 2+2 ## [1] 4 Végrehajtás után a konzolban láthatjuk az összeadás eredményét a 4-et. Az eredmény előtt egy szögletes zárójelben lévő sorszámot is láthatunk ([1]), amely bonyolultabb outputokban segít eligazodni. Később visszatérünk a [1] értelmezésére. Látjuk, ebben az esetben az R úgy viselkedik, mint egy számológép. A parancssorba gépelt algebrai kifejezés értékét kiszámolja és a képernyőn megjeleníti. Természetesen az összeadáson túl más műveletet is használhatunk. 4+6*2 ## [1] 16 A fenti példából látható, hogy az R követi a műveletek elvégzésének matematikában megszokott sorrendjét. Azaz a szorzás művelet (*) hamarabb sorra kerül, ennek eredménye 12. Ezt követi az összeadás (+) most már a 4 és a 12 között. Ennek az összeadás műveletnek az eredménye (16), ami egyben a kifejezés értéke is, tehát ez jelenik meg a konzolban. (4+6)*2 ## [1] 20 Természetesen a matematikában megszokott módon változtathatunk a műveletek végrehajtásának alapértelmezett sorrendjén, használhatunk kerek zárójeleket. Ezeket az R a megszokott módon értelmezi: a zárójelben szereplő műveletek végrehajtását előreveszi. A fenti példában tehát az összeadás művelet lesz az első, amelynek az eredménye 10. Ezt követi a szorzás, így kapjuk a kifejezés értékeként a 20-at. Ezeket a matematikában megszokott algebrai kifejezéseket, az R-ben egyszerűen kifejezésnek vagy – utalva arra, hogy a kifejezés értéke szám – aritmetikai kifejezésnek nevezünk. Az eddigiek alapján az aritmetikai kifejezések tehát a következő nyelvi elemeket tartalmazhatják: számok, amelyeket az R numerikus konstansoknak nevez, műveleti jelek, az aritmetikai operátorok, és kerekzárójelek. A fentiek alapján összetettebb aritmetikai kifejezéseket is megfogalmazhatunk az R parancssorában. Az R minden esetben kiszámolja a kifejezések értékét – kiértékeli a kifejezést – és a kapott értéket megjeleníti a konzolban. 4^2-3*2 ## [1] 10 (56-14)/6-4*7*10/(5**2-5) ## [1] -7 Az R-ben használható aritmetikai operátorokat a precedencia csökkenő sorrendjében a következő táblázat tartalmazza. TÁBLÁZAT 3.1: Matematikai operátorok precedenciája csökkenő sorrendben Operátor formája Művelet Példa Példa eredménye ^ (vagy **) hatványozás 2^3 2**3 8 8 + - (unáris)) előjelek +3.3 -.5 3.3 -.5 %% %/%) maradékos osztás és egész osztás 13%%4 15%/%4 1 4 * /) szorzás és osztás 2*3 4/2 6 2 + - (binér)) összeadás és kivonás 2+3 2-3 5 -1 Az aritmetikai kifejezések használata során ne felejtkezzünk meg az operátorok precedenciájáról sem. -2^2 ## [1] -4 (-2)^2 ## [1] 4 Itt a hatványozás és az előjel operátor közötti végrehajtási sorrend okozza az eltérő eredményeket. Eddig láthattuk, hogy kifejezéseinket operátorok, számok és zárójelek segítségével építettük fel. Ezek a kifejezések két részletükben is általánosíthatók: a kifejezés adat része, amelyet eddig a numerikus konstansok képviseltek, a kifejezés műveleti részében, amelyet eddig az operátorok jelenítettek meg. Az adatrész általánosítása az objektum a műveleteké pedig a függvény. Ezeket tekintjük át a következőkben. "],
["objektumok.html", "3.2 Objektumok", " 3.2 Objektumok Ha egy kifejezés értéket nem egyszerűen a képernyőn szeretnénk megjeleníteni, hanem azt később is fel akarjuk használni, akkor objektumokat kell létrehoznunk. A memóriában tárolt adatok elérésére az R-ben objektumneveken keresztül lehetséges. (Más programozási nyelvekben ezt változónak nevezik, kerüljük ezt az elnevezést a statisztikában használt és így foglalt változó fogalom miatt.) 1157/13+2^3 ## [1] 97 Tudjuk, ha a fenti aritmetikai kifejezést a parancssorba írjuk, az R miután kiértékelte a kifejezést, a kifejezés értékét a megjeleníti a konzolban. Ez az érték azonban a megjelenítés után rögtön el is vész, többször nem használhatjuk fel. x &lt;- 1157/13+2^3 Ha azonban létrehozunk egy x nevű objektumot a fenti módon, akkor ezt az értéket további kifejezésekben is szerepeltethetjük. Minden olyan helyen, ahol eddig számok jelentek meg a kifejezésekben, oda ez az x objektumnév is beírható. Írhatjuk tehát a következőket: x+2 ## [1] 99 2*x^3+5 ## [1] 1825351 Minden objektumnak van neve és tartozik hozzá a memóriában egy terület, ahol a kérdéses érték tárolásra kerül. Esetünkben az objektum neve x a hozzá tartozó memóriaterületen pedig a 97 értéket tárolja az R. Az objektumok kezeléséhez 3 művelet kapcsolódik közvetlenül: objektum létrehozása, objektum értékének lekérdezése objektum értékének megváltoztatása. 3.2.1 Objektumok létrehozása Objektumot értékadással hozhatunk létre. Az értékadás tartalmaz egy értékadás operátort, melynek alakja &lt;-, vagyis egy kisebb jel és egy mínusz előjel egymás után írva szóköz nélkül. (További értékadó operátorok a -&gt;, &lt;&lt;-, -&gt;&gt; és a =. Ezekről később lesz szó.) Az értékadás általános alakja: objektumnév &lt;- kifejezés Ahol lehet a továbbiakban ezt a “balra nyíl” alakú értékadó operátort használjuk az értékadás során, és nem a szintén legális egyenlőségjelet (=). Az egyenlőségjelet megtartjuk a függvényargumentumok elnevezésére. Az egyszerűség kedvéért a “balra nyíl” előtt lévő objektumnevet az értékadás “bal oldalának”, az utána lévő kifejezést az értékadás “jobb oldalának” nevezzük. Ha olyan objektumnevet szerepeltetünk az értékadásban, amely még nem létezik, akkor az R létrehoz egy ilyen nevű új objektumot, és a hozzá tartozó memóriaterületen pedig az értékadás jobb oldalán lévő kifejezés kiértékelése után kapott értéket tárolja el. a &lt;- 1+2 A fenti sor végrehajtása után a konzolban nem jelenik meg eredmény, de nagyon is fontos dolog történik, létrejön az a nevű objektum, amelynek értéke 3 lesz mindaddig, amig meg nem változtatjuk azt. A munkánk során létrehozott objektumok a memória egy speciális területére a munkaterületre (workspace) kerülnek. Ha az értékadásban használt objektumnév már létezik, akkor a jobb oldali kifejezés kiértékelése után a kapott értékkel felülírja a bal oldali objektumhoz tartozó memóriaterületet. Ezzel a módszerrel tehát korábban létrehozott objektum értékét módosíthatjuk. a &lt;- 10/3 A fenti sor hatására a már létező a objektum értékét változtattuk meg. 3.2.2 Objektumok értékének lekérdezése Az objektum memóriában tárolt értékét le is kérdezhetjük. A legegyszerűbb mód erre, ha az objektum nevét a parancssorba írjuk a ## [1] 3.333333 Objektumot azonban kifejezésekben is felhasználhatjuk, akár értékadás jobb oldalán lévő kifejezésben is. a*3 ## [1] 10 a &lt;- 4+a*3 a ## [1] 14 A fenti sorokból kiovasható, hogy immár az a objektum értéke 14. 3.2.3 Objektumok elnevezése Az objektumok elnevezésére eddig egyetlen betűt használtunk, de ez elég ritka eset a munka során. Helyes gyakorlat, ha az objektum neve utal az objektum tartalmára, céljára. Ha például testmagasságot tárolonk el egy objektumban, akkor írhatjuk a következőt: magassag &lt;- 179 A fenti sor létrehozza a munkaterületen a magassag nevű objektumot 179 értékkel. Az objektumok elnevezésére betűket, számjegyeket, a pont (.) és az aláhúzás (_) szimbólumokat használhatjuk. Az objektum neve csak betűvel vagy ponttal kezdődhet, számjeggyel vagy aláhúzással nem. Továbbá a név nem lehet az R-ben már lefoglalt kulcsszó, mint például if, function vagy TRUE (a kulcsszavak listáját a ?Reserved parancsal ismerhetjük meg). Hagyományosan a pont karaktert használjuk az objektumnevekben a tagolására. Az R a magyar ékezetes karakterek használatát is megengedi az objektumnevekben, de csakúgy mint az állományok és könyvtárak elnevezésében, érdemes ezek használatát mellőzni. Az objektumoknak érdemes „beszédes” nevet választani, még ha ennek az ára némi extra gépelés is. (Tudjuk, a Tab billentyű amúgy is segíti a gépelést.) Az R kis- és nagybetű érzékeny, vagyis az x és a X különböző objektumoknak számítanak. Például a következő pulzus.atlag &lt;- 72 parancs után a Pulzus.atlag sor hibát jelez (Error: object 'Pulzus.atlag' not found), azaz a Pulzus.atlag objektumot nem találja az R. Minden olyan esetben, ha nem létező objektumra hivatkozunk, a fenti hibaüzenet jelenik meg a konzolban. Pulzus.atlag &lt;- 69 # Új objektumot hozunk létre pulzus.atlag; Pulzus.atlag ## [1] 72 ## [1] 69 A fenti példában már gondoskodtunk a nagy ’P’-vel kezdődő objektumról is, így lehetőségünk van hibaüzenet nélkül mindkét objektum érékének kiíratására. A gyakorlatban kerüljük el az olyan helyzeteket, amikor két objektumnév csak kis- nagybetűk használatában tér el. Ez a példa két további apró újdonságot is tartalmaz. Megjegyzést az R-ben a kettőskereszt (#) karakter használatával vezetünk be, az R értelmező a kettős kereszttől a sor végéig tartó részt figyelmen kívül hagyja. Itt helyezhetjük el a paranccsal kapcsolatos magyarázatainkat magunk vagy a kódot később olvasók számára. Továbbá, ha a parancssorban több utasítást szeretnénk elhelyezni, akkor ezeket pontosvesszővel (;) kell elválasztanunk. Ezeket az utasításokat az R értelmező egymás után, balról jobbra haladva hajtja végre, mintha külön sorba írtuk volna őket. 1+2; 3+4; 5+6 ## [1] 3 ## [1] 7 ## [1] 11 A fenti sor 3 kifejezést tartalmaz pontosvesszővel elválasztva, mindegyik eredménye külön-külön jelenik meg a konzolban, mintha 3 különböző sorba írtuk volna őket. "],
["feladatok-1.html", "3.3 Feladatok", " 3.3 Feladatok Gondoljuk át, hogy mi lehet a következő algebrai kifejezés eredménye, majd ellenőrizzük R-ben is: \\[8/2(2+2)\\] Gondoljuk át, hogy a .342e1 név, miért nem lehet érvényes objektumnév? Próbáljuk ki a make.names(\".342e1\") parancsot, majd tanulmányozzuk a ?make.names leírást! Magyarázzuk meg a make.names(c(\"\", \"\", \"\")) és a make.names(c(\"\", \"\", \"\"), unique = T) parancsok közötti különbséget! Gondoljuk át, hogy egy parancsállomány mely pontjain érdemes feltétlenül megjegyzéseket használni! Az RStudio-ban parancsállomány (.R) szerkesztése közben próbáljuk ki a Ctrl+Shift+R (macOs-en Cmd+Shift+R) billenytűparancsot, és a hozzá kapcsolódó Shift+Alt+J billenytűparancsot is. Mi a jelentése az Alt+L, Shift+Alt+L, Alt+O és Shift+Alt+O billentyűparancsoknak? A most megismert funkciók, hogyan válthatók ki RMarkdown (.Rmd) állomány szerkesztése közben. "],
["fuggvenyek.html", "4 Függvények", " 4 Függvények Ebben a fejezetben áttekintjük: a függvényhívás módja, nevesített argumentumok, alapértelmezések, argumentumok sorrendje matematikai függvények a munkaterület és az aktuális könyvtár függvényei a csomagkezelő függvények Az aritmetikai kifejezéseinkben használható operátorok nem teszik lehetővé minden matematikai művelet elvégzését. Mit tegyünk ha a 2 négyzetgyökét szeretnénk kiszámolni? A négyzetgyökvonás operátor nem létezik az R-ben, de ebben a speciális esetben a hatványozás operátor segítségével elérhetjük a célunkat. 2^0.5 ## [1] 1.414214 Az R azonban más lehetőséget is biztosít a négyzetgyök kiszámítására és ez az sqrt() függvény. sqrt(2) ## [1] 1.414214 A függvények valamilyen utasítássorozatot hajtanak végre és a számítás eredményét szolgáltatják. Esetünkben az sqrt() függvény egy szám négyzetgyökét számolja ki, annak a számnak, amely a kerek zárójelek között szerepel. Tehát az R a paraméterben megadott 2 értékre meghívja az sqrt() függvényt, ami visszatér a 2 négyzetgyökével. "],
["a-fuggvenyhivas-szabalyai.html", "4.1 A függvényhívás szabályai", " 4.1 A függvényhívás szabályai A R számos beépített függvény hívását teszi lehetővé. A függvényhívás általános alakja: függvénynév(argNév1=arg1, argNév2=arg2, ..., argNévN=argN). A függvény neve ugyanazoknak a szabályoknak engedelmeskedik, amelyeket az objektumok nevénél megtárgyaltunk (lévén a függvény is egy objektum). A függvény neve után kerek zárójelben következnek a függvény argumentumai, amelyek a függvény utasításainak a bemenő paraméterei. A függvény a bemenő paraméterek alapján az utasításainak megfelelően egy visszatérési értéket fog szolgáltatni. Egy függvény hívásainál előforduló argumentumok száma és azok sorrendje igen változatos képet mutathat. Elöljáróban elmondhatjuk, hogy a függvények argumentumai alapértelmezett értékkel is rendelkezhetnek, így ezek az argumentumok elhagyhatók. Továbbá, a függvények argumentumai névvel is rendelkeznek, amelyeket ha a függvény hívásánál felhasználjuk, az argumentumok sorrendje hívásnál átrendezhető. Először tekintsük át az R alapvető matematikai függvényeit. TÁBLÁZAT 4.1: Az R alapvető matematikai függvényei Függvény Leírás Példa Példa értéke abs(x) abszolútérték függvény abs(-1) 1 sign(x) előjel függvény sign(pi) 1 sqrt(x) négyzetgyök függvény sqrt(9+16) 5 exp(x) exponenciális függvény exp(1) 2.718282 log(x) természetes alapú logaritmus log(exp(3)) 3 log(x,base) tetszőleges alapú logaritmus log(100, 10) 2 log10(x) log2(x) 10-es és 2-es alapú logaritmus log10(1000); log2(256) 3 8 cos(x) koszinusz függvény (x radiánban mért) cos(pi) -1 sin(x) szinusz függvény (x radiánban mért) sin(pi/2) 1 tan(x) tangens függvény (x radiánban mért) tan(0) 0 acos(x) asin(x) atan(x) inverz trigonometrikus függvények (x radiánban mért) 2*asin(1); acos(-1); atan(pi) 3.141593 3.141593 1.262627 cosh(x) sinh(x) tanh(x) hiperbolikus trigonometrikus függvények cosh(0); sinh(0); tanh(0) 1 0 0 acosh(x) asinh(x) atanh(x) inverz hiperbolikus trigonometrikus függvények acosh(0); asinh(0); atanh(0) NaN 0 0 round(x, digits=0) kerekítés adott tizedesre round(1.5); round(-1.5) 2 -2 floor(x) x-nél kisebb, legnagyobb egész floor(1.5); floor(-1.5) 1 -2 ceiling(x) x-nél nagyobb, legkisebb egész ceiling(1.5); ceiling(-1.5) 2 -1 trunc(x) az x-hez legközelebbi egész x és 0 között trunc(1.5); trunc(-1.5) 1 -1 Nézzük meg részletesebben a log() függvényt. Ha kikérjük a súgóját ?log parancs begépelésével, akkor megtudhatjuk, hogy ez a legáltalánosabb logaritmus függvény, tetszőleges alap esetén hívható. Számunkra most a legfontosabb a súgónak az sora, amely a logaritmus függvény használatát mutatja: log(x, base=exp(1)). Ebből kiolvasható, hogy a log() függvénynek 2 paramétere van. Az elsőt x-nek, a másodikat base-nek nevezik. A második paraméter alapértelmezett értékkel is rendelkezik, tehát ez a paraméter a hívásnál elhagyható, míg az x= argumentum megadása kötelező. A base= paraméter értéke könnyen kideríthető az exp(1) ## [1] 2.718282 parancsból. Ezt az irracionális számot a matematikában e-vel jelöljük, és a természetes alapú logaritmus alapjának nevezzük. Vagyis, ha nem határozzuk meg a második paramétert, akkor a log() függvény, természetes alap estén számítja az x= logaritmusát. Ezek alapján 2 természetes alapú logaritmusát a log(2) ## [1] 0.6931472 függvényhívás adja meg. Azt is megtehetjük, hogy felhasználjuk hívásnál az argumentum nevét (x), és egy egyenlőségjel (=) felhasználásával ezt a 2 elé szúrjuk be. A log(x=2) ## [1] 0.6931472 sor természetesen ugyanazt az eredményt szolgáltatja, csak most explicit módon közöltük, hogy az aktuális paraméterben szereplő 2-es értéket az x= nevű formális paraméternek feleltetjük meg. Ez most felesleges gépelést jelentett és általában is elmondhatjuk, hogy matematikai függvények esetében az oly gyakori x= argumentumnevet szokás szerint nem használjuk az aktuális paraméterek elnevezésére. Hívjuk most két argumentummal a log() függvényt. A 100 10-es alapú logaritmusát a log(100, 10) ## [1] 2 parancsból olvashatjuk ki. A függvényhívásnál az x= formális argumentum a 100, a base= pedig a 10 értéket kapja. Természetesen ezt a hívásnál mi is rögzíthetjük a világosabb értelmezés kedvéért saját magunk számára a log(100, base=10) ## [1] 2 vagy akár log(x=100, base=10) ## [1] 2 formában is. Arra is lehetőség van, hogy megcseréljük az aktuális paraméterek sorrendját. A legbiztonságosabb ekkor az összes paraméter nevesítése, log(base=10, x=100) ## [1] 2 de két argumentum esetén így is egyértelmű a hozzárendelés: log(base=10, 100); log(10, x=100) ## [1] 2 ## [1] 2 Ha az argumentumok nevesítése nélkül cseréljük fel az aktuális paramétereket, akkor természetesen nemvárt eredményt kapunk, mert az a 10 szám 100-as alapú logaritmusa lesz. log(10, 100) ## [1] 0.5 Kényelmi lehetőség az aktuális paraméterek elnevezésénél, hogy rövidítéseket is használhatunk, addig csonkolhatjuk az argumentum nevét, amíg az argumentumok egyértelműen azonosíthatók maradnak. Így a példában akár a b=-vel is helyettesíthetjük a base= argumentumnevet: log(b=10, 100) ## [1] 2 Mint korábban említettük, az x= argumentum nem rendelkezik alapértelmezett értékkel, így paraméter nélkül nem hívható a log() függvény. log() ## Error: argument &quot;x&quot; is missing, with no default A fenti hibaüzenethez hasonlót láthatunk, ha egy függvényt hibás paraméterszámmal hívunk. Eddig a függvények aktuális paramétereiként csak numerikus konstansokat használtunk, pedig tetszőleges kifejezéseket is megadhatunk. A függvényhívása előtt ezek kiértékelődnek és a hívás során ezek az értékek rendelődnek a formális paraméterekhez. alap &lt;- 10; log(exp(1)); log(exp(4), base=alap); log(2*exp(2), b=alap/2) ## [1] 1 ## [1] 1.737178 ## [1] 1.673346 A fenti példa a következő numerikus konstansokkal történő hívásoknak felel meg: log(2.718282); log(54.59815, base=10); log(14.77811, base=5) ## [1] 1 ## [1] 1.737178 ## [1] 1.673346 Mostanra rendelkezünk elég ismerettel, hogy a kifejezés fogalmát pontosíthassuk: egy konstans, egy objektum vagy egy függvényhívás önmagában kifejezés, de ezek operátorokkal és kerekzárójelekkel helyesen összefűzött sorozata is kifejezés. Az R nyelv parancsai, vagy más néven utasításai lényegében kifejezések. Az R nyelvben egy parancs végrehajtása lényegében egy kifejezés kiértékelését jelenti, és a legtöbb esetben a kifejezés értékének megjelenítését a konzolban. A munka során az R értelmező az utasítások egymás utáni kiértékelését végzi. Az utasításokat újsor karakter vagy pontosvessző választhatja el. A szintaktikailag helyes utasítások kiértékelése mindig egy értéket eredményez, ez lesz az utasítás értéke. Még akkor is rendelkezik értékkel az utasításunk, ha az nem jelenik meg a parancssorban, például az értékadó utasítás értéke a jobb oldali kifejezés értéke. Ezért írhatjuk a következő parancsot: y &lt;- x &lt;- 10 x; y ## [1] 10 ## [1] 10 Amennyiben egy értékadás, mint kifejezés értékét szeretnénk megjeleníteni a konzolban, akkor tegyük kerekzárójelbe a teljes sort: (x &lt;- 20) ## [1] 20 "],
["a-munkaterulet-fuggvenyei.html", "4.2 A munkaterület függvényei", " 4.2 A munkaterület függvényei Megbeszéltük, hogy a munka során az objektumaink a memória speciális területére, a munkaterületre (workspace) kerülnek. Ha még korábban nem is hoztunk létre objektumot, akkor a következő három parancs, három objektumot hoz létre a munkaterületen: fib.0 &lt;- 0 fib.1 &lt;- 1 fib.2 &lt;- fib.0 + fib.1 A munkaterületen létrehozott objektumok neveit az ls() függvény listázza ki: ls() ## [1] &quot;fib.0&quot; &quot;fib.1&quot; &quot;fib.2&quot; A munkaterületről objektumot az rm() paranccsal távolíthatunk el, például a rm(fib.0) # fib.0 törlése ls() ## [1] &quot;fib.1&quot; &quot;fib.2&quot; a fib.0 objektumot távolította el, így az ls() eredményében ez nem is szerepel. Az összes munkaterület-objektum eltávolítása a rm(list = ls()) # összes objektum törlése ls() ## character(0) segítségével történik. "],
["a-munkakonyvtar-fuggvenyei.html", "4.3 A munkakönyvtár függvényei", " 4.3 A munkakönyvtár függvényei Az R használata során mindig van egy kitüntett, aktuális könyvtárunk, amelyet munkakönyvtárnak nevezünk. A munkakönyvtár célja, hogy az állományok nyítása és mentése során, ha nem használunk külön könyvtárhivatkozást, akkor ez lesz az alapértelmezett könyvtár. A munkakönyvtár az R-ben lekérdezhető ill. beállítható a getwd() és a setwd() parancsok kiadásával. Például getwd() setwd(&quot;C:/Data/peldak&quot;) parancsokkal először megismerjük az aktuális könyvtárat, majd megváltoztatjuk a C:/Data/peldak könyvtárra. Figyeljük meg, hogy az elérési útban perjelet (/) használtunk. Megjegyezzük, hogy az RStudio projekt üzemmódú használata során nincs szükség a munkakönyvtár beállítására a setwd() paranccsal, sőt, kerüljük a használatát. A munkakönyvtárunk a munka során végig maradjon meg az alapértelmezetten beállított könyvtár, maga a projektkönyvtár. A munkakönyvtár jelentőségét tovább növeli, hogy az R indításakor ebben a könyvtárban 2 állomány létezését figyeli: * .Rhistory (a visszahívható parancsokat tartalmazó szöveges állomány) * .RData (a tárolt objektumokat tartalmazó bináris állomány). A fenti állományok ugyanis betöltésre kerülnek az R indításakor, ha azokat az R megtalálja a munkakönyvtárban. Így ezek után, az .Rhistory állományból jövő parancsok között válogathatunk a parancssor használata során, illetve az .RData állományban tárolt objektumok azonnal elérhetőek, vagyis lesz egy induló munkaterületünk. "],
["csomagkezelo-fuggvenyek.html", "4.4 Csomagkezelő függvények", " 4.4 Csomagkezelő függvények Korábban megbeszéltük, hogy a csomagok adatobjektumokat és függvényeket tartalmaznak. Az ún. egyéb csomagok (számuk kb. 17000) elsődleges célja az Alap R tudásának kiegészítése. Az R indítása után néhány csomag automatikusan betöltésre kerül a standard csomagok közül. Ezeket a csomagokat és egyéb ún. környezeteket listázhatunk ki a search() függvénnyel. search() ## [1] &quot;.GlobalEnv&quot; &quot;package:stats&quot; &quot;package:graphics&quot; ## [4] &quot;package:grDevices&quot; &quot;package:utils&quot; &quot;package:datasets&quot; ## [7] &quot;package:methods&quot; &quot;Autoloads&quot; &quot;package:base&quot; A fenti eredményben a package karaktersorozattal kezdődő elemek mutatják, hogy melyek az éppen betöltött csomagok. A listában nem szereplő, de korábban telepített csomagok betöltéséhez használjuk a library() vagy require() függvényeket. library(MASS) require(foreign) search() ## [1] &quot;.GlobalEnv&quot; &quot;package:foreign&quot; ## [3] &quot;package:MASS&quot; &quot;tools:rstudio&quot; ## [5] &quot;package:stats&quot; &quot;package:graphics&quot; ## [7] &quot;package:grDevices&quot; &quot;package:utils&quot; ## [9] &quot;package:datasets&quot; &quot;package:methods&quot; ## [11] &quot;Autoloads&quot; &quot;package:base&quot; A fenti példában a MASS és a foreign csomag betöltését és annak hatását követhetjük nyomon a search() függvény ouputjára. Egy csomag betöltése azt jelenti, hogy a csomagban lévő függvényeket és objektumok a memóriába kerültek, azokat a parancsainkban ezután szabadon felhasználhatjuk. Egy adott csomagban (esetünkben a foreign csomagban) lévő függvények és objektumok a library(help=foreign) vagy a help(package=foreign) paranccsal kérdezhetők le. Betöltött csomagok esetében használhatjuk az ls(name=&quot;package:foreign&quot;, all.names = T) ## [1] &quot;data.restore&quot; &quot;lookup.xport&quot; &quot;read.arff&quot; ## [4] &quot;read.dbf&quot; &quot;read.dta&quot; &quot;read.epiinfo&quot; ## [7] &quot;read.mtp&quot; &quot;read.octave&quot; &quot;read.S&quot; ## [10] &quot;read.spss&quot; &quot;read.ssd&quot; &quot;read.systat&quot; ## [13] &quot;read.xport&quot; &quot;write.arff&quot; &quot;write.dbf&quot; ## [16] &quot;write.dta&quot; &quot;write.foreign&quot; parancsot is, amely a csomag adatobjektumainak és függvényeinek a nevét listázza. Betöltött csomagot a detach() függvénnyel távolíthatunk el a memóriából: detach(package:foreign) search() ## [1] &quot;.GlobalEnv&quot; &quot;package:MASS&quot; ## [3] &quot;tools:rstudio&quot; &quot;package:stats&quot; ## [5] &quot;package:graphics&quot; &quot;package:grDevices&quot; ## [7] &quot;package:utils&quot; &quot;package:datasets&quot; ## [9] &quot;package:methods&quot; &quot;Autoloads&quot; ## [11] &quot;package:base&quot; Ha a használni kívánt csomag még nincs telepítve a számítógépünkre, akkor a @ref(Csomagok_telepitese) fejeztben ismertetett módok egyikét válasszuk, attól függően, hogy a csomag melyik tárhelyről érhető el. A CRAN-ról elérhető csomagok közül telepítsük fel a DescTools és psych csomagokat: install.packages(&quot;DescTools&quot;) install.packages(&quot;psych&quot;) A számítógépünkön telepített csomagokról az installed.packages() függvény ad tájékoztatást. Amennyiben a csomagok &lt;- installed.packages() View(csomagok) # RStudio-ban vagy RGui-ban parancsot kiadjuk az RStudio-ban, akkor csomagjainkat kényelmesen áttekinthetjük. Csomagok frissítésére használjuk az update.packages() parancsot. "],
["feladatok-2.html", "4.5 Feladatok", " 4.5 Feladatok Telepítsük számítógépünkre az R Commander csomagot az install.packages(\"Rcmdr\") parancs segítségével, majd töltsük be a library(Rcmdr) Mi a különlegessége ennek a csomagnak? Milyen helyzetekben érdemes használni? Hasonlítsuk össze az RStudio-val, mik az előnyei és hátrányai az RStudio-val szemben! Keressük meg a The R Journal 2018, vol 10,2 számában a “Navigating the R Package Universe” c. cikket. Mit tudtunk meg belőle? A cikkben említett csomagot telepítsük fel a számítógépünkre! Mi a csomag tartalma? Fogalmazzuk meg, hogy miért kimondottan tilos a setwd() használata az RStudio projektes használata során! "],
["adatszerkezetek.html", "5 Adatszerkezetek", " 5 Adatszerkezetek Ebben a fejezetben áttekintjük: numerikus, karakteres és logikai értékek írása Ebben a fejezetben újra visszatérünk az adatokhoz. Eddig csak számszerű (numerikus) adatokkal találkoztunk, és azok közül is az egyszerűség miatt csak az egész számok leírására fókuszáltunk. Adatfeldolgozási folyamatainkban a mért adatok azonban tipikusan 4 alaptípusban fordulhatnak elő: integer vagy double (ezeket összefoglalóan numerikus alaptípusoknak nevezük), karakteres és logikai. "],
["alaptipusok.html", "5.1 Alaptípusok", " 5.1 Alaptípusok 5.1.1 Numerikus értékek A numerikus értékek többféle alakban is megjelenhetnek az R-ben. Az integer szóval az egész számok tárolását végző alaptípusra hivatkozunk, a double típusú számok pedig törtrészt is tartalmazhatnak. Ha nem érdekes, hogy a szám integer vagy double, akkor egyszerűen a numerikus típus (R-ben numeric) kifejezést használjuk. TÁBLÁZAT 5.1: Numerikus értékek írása Numerikus érték formája az R-ben Értéke Leírás 1, -1, 2, 100, 3.5, .4 1, -1, 2, 100, 3.5, 0.4 pozitív és negatív double számok 1L, -1L, 2L, 100L 1, -1, 2, 100 pozitív és negatív integer számok az ’L’ suffix-szal 1.2e3, 3e+4, .6e-2, 4e1L 1200, 30000, 0.006, 40 exponenciális alakú integer és double számok 0xef, 0XF01, -0xEf03, 0xd1L 239, 3841, -61187, 209 hexadecimális integer és double számok Az R-ben minden objektumnak van típusa. A fenti értékeket tekinthetjük név nélküli objektumoknak. Az alaptípus kiírásáért a typeof() és a class() függvény felel. Működésük kissé eltérő, ezért érdemes párhuzamosan használni őket. typeof(12) # double ## [1] &quot;double&quot; class(12) # numeric, a class() fv. numeric alatt a double-t érti ## [1] &quot;numeric&quot; typeof(12L) # integer ## [1] &quot;integer&quot; class(12L) # integer ## [1] &quot;integer&quot; A fenti példákból látható, hogy integer értékek írásához szükséges az L suffix használata, egyébként double-ként kezeli az R a számot, még akkor is ha nem adtunk meg törtrészt. A class() függvény esetében a numeric output double-t jelent. Ez az egyik eltérés a két függvény működésében. Tizdestörtek esetén double-t kapunk eredményül: typeof(3.2) # double ## [1] &quot;double&quot; class(3.2) # numeric ## [1] &quot;numeric&quot; Fontos szabály, hogy a tizdesvessző alakja az R-ben a pont. A nulla egészrészű tizedestörtek esetében az értéktelen 0-át elhagyhatjuk. 0.04 ## [1] 0.04 .04 ## [1] 0.04 -.04 # negatív szám, a nulla egészrész megadása nélkül ## [1] -0.04 Használhatunk az R-ben exponenciális alakú és hexadecimális (16-os számrendszerű) számokat is. 12e3 ## [1] 12000 12E+3 ## [1] 12000 12e-3 ## [1] 0.012 0xa2e ## [1] 2606 0Xa2e ## [1] 2606 Az exponenciális alakú számokat e vagy E karakter vágja ketté, egy bal oldali és egy jobb oldali részre. Az exponenciális alakú szám értéke: a bal oldali rész szorozva 10 anyiadik hatványával, mint amennyi a jobb oldali rész. Értsük jól az exponenciális alakú számokat: a szám előjelét a bal oldali rész előjele dönti el (pozitív vagy negatív lehet), viszont a nagyságrendjét a jobb oldali szám nagyságrendje és előjele együtt határozza meg. Az exponenciális alakú számok nagy előnye, hogy a nagyon kis, illetve nagyon nagy számok nagyságát jobban meg tudjuk ítélni. 0.0000000000000000000000000016726 # proton tömege ## [1] 1.6726e-27 0.00000000000000000000000000000091093822 # elektron tömege ## [1] 9.109382e-31 100000000 # ennyi fele kell figyelni egy diáknak (százmillió) ## [1] 1e+08 5970000000000000000000000 # A Föld tömege ## [1] 5.97e+24 Az R automatikusan exponenciális alakra vált túl kicsi vagy túl nagy számok konzolba írásánál. Ezt a viselkedést az R egyik globális opciójának beállításával tudjuk némileg szabályozni. A globális opciókat azoptions() függvénnyel tudjuk állítani az R-ben (?options), amelyben most a scipen= integer típusú paramétert kell megadunk. Minél nagyobb pozitív értéket adunk meg, annál jobban törekzik az R a számok fix alakú megjelenítésére, negatív érték megadásánál pedig ugynez igaz az exponenciális alakra. options(scipen = 0) # az alapértelmezés 0.0000001 # túl kicsi: exponenciális lesz ## [1] 1e-07 123 # marad fix alakú ## [1] 123 100000000 # túl nagy: exponenciális lesz ## [1] 1e+08 options(scipen = -8) # legyenek inkább exponenciális alakúak a számaink 0.0000001 # exponenciális lesz ## [1] 1e-07 123 # exponenciális lesz ## [1] 1.23e+02 100000000 # exponenciális lesz ## [1] 1e+08 options(scipen = 8) # legyenek inkább fix alakúak a számaink 0.0000001 # fix lesz ## [1] 0.0000001 123 # fix lesz ## [1] 123 100000000 # fix lesz ## [1] 100000000 options(scipen = 0) # az alapértelmezés visszaállítása A 16-os számrendszerű számok írásához a 0-9 és a kis a-f vagy nagy A-F betűket használhatjuk fel. A hexadecimális számokat a 0x vagy 0X prefix vezeti be. Aritmetikai műveleteinkben rendszerint double típusú számokat, 10-es számrendszerben és fix (nem exponenciális) alakban használunk. De ettől bármikor eltérhetünk: 12L + -3.04 + 3.4e2 + -0x1af # különböző formában írt pozitív és negatív számok összeadása ## [1] -82.04 A számok megjelenését a konzolban még egy globális opció befolyásolja. A digits megszabja, hány értékes jegyre pontosan jelenjenek meg a számaink. Lehetséges értéke 1-22 tartományba esik, alapértelmezése a 7. A beállított érték csak egy ajánlás, és főképp tizedestörtek esetén okozhat meglepetést, ha túl kicsire állítjuk a digits értékét. options(digits = 1) 12.36 ## [1] 12 options(digits = 2) 12.36 ## [1] 12 options(digits = 3) 12.36 ## [1] 12.4 options(digits = 4) 12.36 ## [1] 12.36 options(digits = 7) # alapértelmezés visszaállítása Természetesen névvel is rendelkező objektumokat is létrehozhatunk a numerikus értékek segjtségével: peter.magassaga &lt;- 181 peter.sulya &lt;- 72 peter.bmi &lt;- peter.sulya /(peter.magassaga/100)^2 5.1.2 Karakteres értékek Az R-ben a karakteres érték (vagy más néven sztring vagy karaktersorozat) idézőjelekkel határolt, tetszőleges karaktereket tartalmazó sorozat. A kakateres érték tehát nem egyetlen karaktert jelent tipikusan, hanem többet. Például: &quot;Helló&quot; ## [1] &quot;Helló&quot; &#39;Itt vagyok&#39; ## [1] &quot;Itt vagyok&quot; Az karakteres értékeket határoló idézőjel lehet egyszeres és dupla is, de egy konstanson belül nem keverhetjük őket. Az R a dupla idézőjelet részesíti előnyben az output kiírása esetén. Egy karakteres érték tetszőleges karaktert (betűt, számjegyet, írásjeleket, szóközt stb.) tartalmazhat, egyedül azt az idézőjelet kell elkerülnünk, amelyet az érték létrehozásánál használtuk. A karakteres értékek tartalmazhatnak ún. escape szekvenciákat, olyan backslash jellel (\\, fordított perjel) kezdődő karaktersorozatokat, amelyeket speciálisan értelmez az R. A legfontosabb escape szekvenciák a következők: TÁBLÁZAT 5.2: Néhány escape szekvencia Escape szekvencia Jelentése Példa Példa értéke \\r kocsi vissza karakter gtools::asc(\"\\r\") 13 \\n új sor karakter gtools::asc(\"\\n\") 10 \\\" dupla idézőjel (\") writeLines(\"Dupla: \\\"\") Dupla: \" \\' szimpla idézőjel (’) writeLines(\"Szimpla: \\'\") Szimpla: ' \\\\ (backslash) karakter writeLines(\"Kettő (\\\\\\\\) kell egy \\\\ jelhez.\") Kettő (\\\\) kell egy \\ jelhez. \\u (vagy \\U) és 4-8 hexa számjegy Unicode karakter3 cat(\"\\U03B2 \\U1f600 \\U00002603\") &lt;Futtassuk önállóan!&gt; A fentiek alapján a következő idézőjel-használatok engedélyezettek a karakteres értékekben: &#39;\\&#39;alma\\&#39;&#39;; &quot;&#39;alma&#39;&quot;; &quot;\\&quot;alma\\&quot;&quot;; &#39;&quot;alma&quot;&#39; ## [1] &quot;&#39;alma&#39;&quot; ## [1] &quot;&#39;alma&#39;&quot; ## [1] &quot;\\&quot;alma\\&quot;&quot; ## [1] &quot;\\&quot;alma\\&quot;&quot; Karakteres objektumokat is létrehozhatunk. nev &lt;- &#39;Zsolt&#39;; foglalkozas &lt;- &quot;festő&quot; Karakteres operátor az Alap R-ben nincs, de számos karakterkezelő függvény segíti a sztringek kezelését. TÁBLÁZAT 5.3: Néhány karakterkezelő függvény Függvény Leírás Példa Példa értéke paste(..., sep=\" \") paste0(..., sep=\"\") sztringek összefűzése paste(\"a\", \"b\", sep=\"=\") \"a=b\" nchar(x) karakterszrting hossza nchar(\"alma\") 4 substr(x, start, stop) sztring egy része substr(\"alma\", 3, 5) \"ma\" tolower(x) kisbetűsre konvertál tolower(\"Kiss Géza\") \"kiss géza\" toupper(x) nagybetűsre konvertál toupper(\"Kiss Géza\") \"KISS GÉZA\" chartr(old, new, x) karakterek cseréje chartr(\"it\",\"ál\",\"titik\") \"lálák\" cat(..., sep) kiíratás cat(\"alma\",\"fa\\n\",sep=\"\") \"almafa\" grep(), grepl(), regexpr() részsztringek keresése grep(pattern = \"lm\", x = c(\"alma\", \"körte\")); grepl(pattern = \"lm\", x = c(\"alma\", \"körte\")) 1 TRUE FALSE sub(), gsub() részsztringek cseréje sub(pattern = \"lm\", replacement = \"nyj\", x = c(\"alma-alma\", \"körte\")); gsub(pattern = \"lm\", replacement = \"nyj\", x = c(\"alma-alma\", \"körte\")) \"anyja-alma\" \"körte\" \"anyja-anyja\" \"körte\" 5.1.3 Logikai értékek Az eddigiekben megismert numerikus és karakteres értékek nagyon sokfélek lehetnek, de ugyanígy a numerikus és karakteres objektumokhoz nagyon sok lehetséges numerikus és karakteres érték rendelhető. A logikai adattípus ezektől lényegesen egyszerűbb típus, mivel összesen két értéket tárolására van módunk. Ezek a logikai igaz és a logikai hamis érték, amelyek az R nyelvben a TRUE és a FALSE logikai értékeket jelentik. Az R a logikai értékek írását a T és F globális változók bevezetésével segíti, ezek induló értéke a TRUE és FALSE logikai érték. Ezeket a logikai értékeket értékadásban is szerepeltethetjük, így logikai objektumokat hozhatunk létre. fiu &lt;- TRUE; van.kocsija &lt;- FALSE; hazas &lt;- T fiu; van.kocsija; hazas ## [1] TRUE ## [1] FALSE ## [1] TRUE Logikai értékeket vagy objektumokat relációs operátorok segítségével is létrehozhatunk. TÁBLÁZAT 5.4: Relációs operátorok Operátor formája Művelet Példa Példa értéke &lt; kisebb 1&lt;2; \"alma\"&lt;\"körte\" TRUE TRUE &gt; nagyobb 3&gt;(1+2); \"abc\"&gt;\"ab\" FALSE TRUE &lt;= kisebb egyenlő 1&lt;=-.3; \"él\"&lt;=\"elő\" FALSE TRUE &gt;= nagyobb egyenlő 3/4&gt;=7/9; \"aki\"&gt;=\"Ági\" FALSE TRUE == egyenlő 20==2e1; \"Len\"==\"len\" TRUE FALSE != nem egyenlő exp(1)!=pi; \"Len\"!=\"len\" TRUE TRUE %in% tartalmazás c(8, 12) %in% 1:10 TRUE FALSE Numerikus és karakteres adatok is lehetnek a relációs operátorok bemenő adatai (operandusai). Numerikus adatok esetén a számok nagysága, karakteres adatok esetén az ábécében elfoglalt hely és a sztringek hossza (lexikografikus sorrend) alapján végzi az R az összehasonlítást. A sztringek lexikografikus összehasonlítása, magyar területi beállítások esetén, a magyar ékezetes karaktereket is helyesen kezeli. Az ilyen, logikai értékkel visszatérő kifejezéseket (egyszerű) logikai kifejezéseknek nevezzük. Ezekből az egyszerű logikai kifejezésekből a logikai operátorok segítségével összetett logikai kifejezéseket hozhatunk létre. TÁBLÁZAT 5.5: Logikai operátorok Operátor formája Művelet Példa Példa értéke ! logikai NEM !(1&lt;2); !TRUE; !FALSE FALSE FALSE TRUE &amp; és &amp;&amp; logikai ÉS TRUE &amp; TRUE; TRUE &amp; FALSE; FALSE &amp; TRUE; FALSE &amp; FALSE TRUE FALSE FALSE FALSE | és || logikai VAGY TRUE | TRUE; TRUE | FALSE; FALSE | TRUE; FALSE | FALSE TRUE TRUE TRUE FALSE http://www.unicode.org/charts/↩ "],
["adatszerkezetek-attekintese.html", "5.2 Adatszerkezetek áttekintése", " 5.2 Adatszerkezetek áttekintése Az előző fejezetben láttuk, hogy az R-ben leírható értékek alapvetően 4 típusba sorolhatók. Ezek az integer, a double, a karakteres és a logikai alaptípusok voltak. Ezen értékek felhasználásával nagyon egyszerűen tudunk objektumokat létrehozni. Ezek az objektumok, mindjárt látjuk, az R legalapvetőbb adateszerkezetének, a vektornak az egyelemű változatai. obj.integer &lt;- 12L obj.double &lt;- 12.03 obj.karakteres &lt;- &#39;Péter&#39; obj.logikai &lt;- TRUE A fenti objektumok alaptípusa rendre integer, double, karakteres és logikai. Ezt könnyen ellenőrizhetjük a typeof() vagy class() függvényekkel. Az adatelemzési problémáink megoldásához azonban egyszerre több adatérték feldolgozása szükséges. Mivel az R nyelvet statisztikai adatfeldolgozásra tervezték, így nem csodálkozunk, hogy több értéket is eltárolhatunk egymás utáni memórihelyeken a fenti 4 alaptípusból. Ezt többféleképp megtehetjük, így kapjuk meg az R különböző adatszerkezeteit, amelyeket tipikusan mért vagy származtatott adatok tárolására használunk: vektor: azonos alaptípusú értékekeket egymás után teszünk, egyvonalba, tipikusan mért vagy származtatott adatok tárolása céljából mátrix: azonos alaptípusú értékekből egy kétdimenziós szerkezetet hozunk létre, amelynek vannak sorai és oszlopai, tipikusan mért vagy származtatott adatok tárolása céljából tömb: azonos alaptípusú értékekből 3 vagy több dimenzió mentén készítünk adatszerkezetet, tipikusan mért vagy származtatott adatok tárolása céljából faktor: integer értékeket egymás után teszünk, egyvonalba, de megadjuk, hogy melyik szám milyen címkét jelöl, tipikusan mért vagy származtatott adatok tárolása céljából dátum: egyetlen double szám, amelynek jelentése az 1970-01-01 óta eltelt napok száma dátum-idő: egyetlen double szám, amelynek jelentése az 1970-01-01 óta eltelt másodpercek száma időtartam: egyetlen double szám, amelynek különböző mértékegységekben mutatja két időpont közötti különséget lista: tetszőleges típusú objektumokat egymás után teszünk, tipikusan mért vagy származtatott adatok tárolása céljából dataframe: tetszőleges típusú, de azonos elemszámú típusú objektumokat egymás után teszünk tibble: a Tidyverse R dataframe típusa TÁBLÁZAT 5.6: Adatszerkezetek Adatszerkezet Létrehozó parancs typeof(x) class(x) integer vektor x &lt;- c(12L, 14L) integer integer double vektor x &lt;- c(12, 14) double numeric karakteres vektor x &lt;- c('a', 'az', 'egy') character character logikai vektor x &lt;- c(T, TRUE, FALSE, F) logical logical integer mátrix x &lt;- matrix(1L, nrow=2, ncol = 3) integer matrix double mátrix x &lt;- matrix(1.3, nrow=2, ncol = 3) double matrix karakteres mátrix x &lt;- matrix('az', nrow=2, ncol = 3) character matrix logikai mátrix x &lt;- matrix(F, nrow=2, ncol = 3) logical matrix integer tömb x &lt;- array(2L, dim=c(2,3,5)) integer array double tömb x &lt;- array(2, dim=c(2,3,5)) double array karakteres tömb x &lt;- array('a', dim=c(2,3,5)) character array logikai tömb x &lt;- array(T, dim=c(2,3,5)) logical array faktor x &lt;- factor(c('D', 'D', 'ND'), level=c('ND', 'D', 'ED')) integer factor dátum x &lt;- as.Date('1971-05-09') double Date dátum-idő x &lt;- as.POSIXct('2018-08-01 22:00', tz = 'UTC') double POSIXct POSIXt időtartam x &lt;- as.difftime(7, units = 'days') double difftime lista x &lt;- list(A='Pék', B=1:2) list list dataframe x &lt;- data.frame(nev=c('a', 'b'), pont=c(11, 9)) list data.frame tibble x &lt;- tibble(x=1:3, y=letters[1:3]) list tbl_df tbl data.frame "],
["vektor.html", "5.3 Vektor", " 5.3 Vektor Az R legalapvetőbb adatszerkezete a vektor. A vektort egymás melletti cellákban tárolt értékek sorozataként képzelhetjük el, mely értékek mindegyike azonos típusú. Így azt mondhatjuk, hogy a vektor azonos típusú (egynemű, homogén) adatok egydimenziós együttese. A vektor fontos jellemző, hogy homogén, tehát a vektort alkotó értékek vagy kizárólag numerikus konstansok, vagy kizárólag karakteres konstansok, vagy kizárólag logikai konstansok. 5.3.1 Vektorok létrehozása Vektort legegyszerűbben a c() függvénnyel hozhatunk létre, a paraméterben sorban felsoroljuk a vektort alkotó értékeket. Numerikus vektort hozhatunk létre, ha a paraméterben numerikus konstansokat sorolunk fel: v1 &lt;- c(2, 4, 6, 8) v1 ## [1] 2 4 6 8 A fenti példában a v1 objektum egy 4 elemű vektor. Az első eleme a 2 numerikus konstans, a második eleme a 4, a harmadik a 6 és a negyedik egyben utolsó eleme a 8. A vektor elemei kiíratáskor szóközökkel elválasztva jelennek meg a konzolban. Karakteres vektort hasonlóan hozhatunk létre: v2 &lt;- c(&quot;erős&quot;, &#39;közepes&#39;, &quot;gyenge&quot;) v2 ## [1] &quot;erős&quot; &quot;közepes&quot; &quot;gyenge&quot; A fenti v2 vektor 3 elemű. Egy logikai vektor csak logikai konstansokat tartalmazhat (TRUE vagy FALSE): v3&lt;-c(TRUE, FALSE, TRUE) v3 ## [1] TRUE FALSE TRUE A v1, v2, v3 objektum egy-egy példa az R különböző típusú vektoraira. Egy vektor típusát a typeof() függvénnyel kérdezhetjük le: typeof(v1); typeof(v2); typeof(v3) ## [1] &quot;double&quot; ## [1] &quot;character&quot; ## [1] &quot;logical&quot; A v1 objektum double típusa a numerikus típusok egyik változata (nem egész értékeket is tárolhatunk benne), a v2 karakteres és a v3 logikai típusa pedig a fenti példából könnyen kiolvasható. Az objektumok fontos jellemzője az objektum hossza, ami vektorok esetén a vektort alkotó elemek számát jelenti. Ezt a length() függvénnyel kérdezhetjük le. length(v1); length(v2); length(v3) ## [1] 4 ## [1] 3 ## [1] 3 Térjünk vissza a vektorok létrehozásához. A c() függvény paraméterébe természetesen konstansok helyett tetszőleges kifejezéseket is írhatunk: szamok&lt;-c(1, (2+3)*4, 1/4, .5^3) szamok ## [1] 1.000 20.000 0.250 0.125 nevek&lt;-c(&quot;Péter&quot;, paste(&#39;Zso&#39;, &quot;lt&quot;, sep=&quot;&quot;)) nevek ## [1] &quot;Péter&quot; &quot;Zsolt&quot; iteletek&lt;-c(T, 1&lt;2, 2==3) iteletek ## [1] TRUE TRUE FALSE A vektorok esetében a homogenitás központi szerepet játszik. Az R abban az esetben sem fog különböző típusú elemekből vektort létrehozni, ha ezeket egyetlen c() függvényhívásban szerepeltetjük. Ekkor automatikus típuskonverzió történik. Nézzük ezeknek az eseteit: eset1&lt;-c(2,4,&quot;6&quot;,8) eset1 ## [1] &quot;2&quot; &quot;4&quot; &quot;6&quot; &quot;8&quot; eset2&lt;-c(T, FALSE,&quot;6&quot;) eset2 ## [1] &quot;TRUE&quot; &quot;FALSE&quot; &quot;6&quot; eset3&lt;-c(T, FALSE, 3) eset3 ## [1] 1 0 3 Amennyiben karakteres konstans szerepel az elemek között a vektor karakteres típusú lesz. Ha numerikus és logikai értéket sorolunk fel, akkor a vektor numerikus lesz, azzal a kiegészítéssel, hogy a TRUE logikai érték 1-re a FALSE pedig 0-ra konvertálódik. További lehetőség a c() függvény használata során, hogy a paraméterben vektort szerepeltessünk. Ekkor ezek az elemek is szerepelni fognak az eredményvektorban: elol &lt;- c(1,2,3) hatul &lt;- c(7,8,9) c(0,elol,4,5,6,hatul,10) ## [1] 0 1 2 3 4 5 6 7 8 9 10 A fenti példában létrehozott (majd el is vesző) 11 elemű vektor összerakásához felhasználtunk két 3 elemű vektort is. Szabályos numerikus vektorokat hozhatunk létre a kettőspont (:) operátorral, a seq() és a sequence() függvénnyel. Az így létrehozott vektorok ugyanis valamilyen számtani sorozat egymást követő elemei, vagyis az egymás mellett lévő elemek különbsége állandó. A legegyszerűbb vektorlétrehozási mód a kettőspont (:) operátor, ahol az egymást követő elemek távolsága 1. Általános alakja: start:stop. 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 10:1 ## [1] 10 9 8 7 6 5 4 3 2 1 -1.5:5 ## [1] -1.5 -0.5 0.5 1.5 2.5 3.5 4.5 Látható, hogy az így létrejövő sorozatok lehetnek csökkenő vagy növekvő rendezettségűek valamint tört értékeket is használhatunk operandusként. A sorozat nem feltétlenül a kettőspont utáni értékig tart, annyi igaz, hogy a stop értéknél mindig kisebb egyenlő. A seq() függvény nagyobb szabadságot ad a numerikus sorozatok generálására. Legegyszerűbb használata esetén a kettőspont (:) operátort kapjuk vissza: seq(1,10) ## [1] 1 2 3 4 5 6 7 8 9 10 A seq() függvény használatához 4 nevesített paraméter jelentését kell megtanulnunk: a from= a sorozat első elemét határozza meg, a to= az utolsó elemet, a by= a lépésközt és a length.out a létrehozandó vektor elemeinek a számát. A négy paraméterből 3 megadása már egyértelműen azonosítja a kívánt vektort: seq(from=1, to=10, by=2) ## [1] 1 3 5 7 9 seq(from=1, to=10, length.out=5) ## [1] 1.00 3.25 5.50 7.75 10.00 seq(to=10, by=1.3, length.out=5) ## [1] 4.8 6.1 7.4 8.7 10.0 seq(from=1, by=1.3, length.out=5) ## [1] 1.0 2.3 3.6 4.9 6.2 A sequence() függvény a paraméterében szereplő értékig, mint végpontig 1-től kezdődő 1 lépésközű sorozatot hoz létre. A függvényt pozitív értékeket tartalmazó vektorral is hívhatjuk, ekkor több, a fenti szabálynak eleget tevő szabályos vektor sorozata lesz az eredményvektor: sequence(4) ## [1] 1 2 3 4 sequence(c(4, 5)) ## [1] 1 2 3 4 1 2 3 4 5 sequence(c(4, 5, 3)) ## [1] 1 2 3 4 1 2 3 4 5 1 2 3 Tetszőleges típusú vektor létrehozására használhatjuk a rep() függvényt, amely egy létező vektor értékeit ismétli meg. rep(2, times=3) ## [1] 2 2 2 rep(c(2, 0, -2), times=3) ## [1] 2 0 -2 2 0 -2 2 0 -2 rep(&quot;tó&quot;, times=3) ## [1] &quot;tó&quot; &quot;tó&quot; &quot;tó&quot; rep(c(F, T, T), times=3) ## [1] FALSE TRUE TRUE FALSE TRUE TRUE FALSE TRUE ## [9] TRUE A fenti példában mindenhol háromszor ismételtük meg az első paramétert, méghozzá úgy, hogy az R egymás után sorolta fel őket. Egy meglévő vektor ismétlésének van egy másik esete is, amikor az elemeit sorban egyenként véve végezzük el az ismétlést. Ekkor nem a times paramétert, hanem az each argumentumot kell használnunk a függvény hívásánál. rep(2, each=3) ## [1] 2 2 2 rep(c(2, 0, -2), each=3) ## [1] 2 2 2 0 0 0 -2 -2 -2 rep(&quot;tó&quot;, each=3) ## [1] &quot;tó&quot; &quot;tó&quot; &quot;tó&quot; rep(c(F,T,T), each=3) ## [1] FALSE FALSE FALSE TRUE TRUE TRUE TRUE TRUE ## [9] TRUE Látjuk, hogy egy elemű vektorok ismétlése esetén nincs különbség a times és az each paraméterek használata között. Utolsó esetként vegyük azt az esetet, amikor elemenként szeretnénk ismételni, de mindegyiket esetleg eltérő mértékben. Ekkor az each paraméterben a bemenő vektor elemszámával azonos hosszú vektort kell megadni. Ez a vektor tartalmazza az egyes elemek ismétlési számát. rep(c(2, 3, 4), c(1, 2, 3)) ## [1] 2 3 3 4 4 4 rep(c(&quot;tó&quot;, &quot;part&quot;), c(2, 3)) ## [1] &quot;tó&quot; &quot;tó&quot; &quot;part&quot; &quot;part&quot; &quot;part&quot; rep(c(T, F, T), c(2, 3, 4)) ## [1] TRUE TRUE FALSE FALSE FALSE TRUE TRUE TRUE ## [9] TRUE 5.3.2 Műveletek vektorokkal Amint azt az előzőekben láttuk, az R rendszer legalapvetőbb adattárolási szerkezete a vektor. Az egyik legnagyszerűbb tulajdonsága pedig az, ahogyan a vektorokkal műveleteket végezhetünk. Korábban már láttuk, hogyan tudunk összeadni két számot az R-ben. Próbáljunk meg összeadni két 2 elemű vektort: c(1, 2) + c(3, 4) ## [1] 4 6 A két fenti vektort a parancssorban hoztuk létre a c() függvénnyel. Az összeadás eredménye egy 2 elemű vektor. Az eredményvektor az 1+3 és a 2+4 műveletek alapján jött létre, vagyis az összeadás operandusaiban szereplő vektor azonos sorszámú elemeire hajtotta végre a kijelölt műveletet az R. Két vektor összeadásánál természetesen használhatunk objektumneveket is: x &lt;- 1:3; y &lt;- 2:4 x+y ## [1] 3 5 7 Itt az eredményvektor 3 elemű, és a komponensenkénti művelet-végrehajtás szabályainak megfelelően az 1+2, 2+3 és a 3+4 összeadások eredménye. Az összeadás műveletet tetszőleges operátorral felcserélhetjük, vektor operandusokkal használhatjuk az összes aritmetikai és logikai operátort. c(1,2)-c(2,3) ## [1] -1 -1 x&lt;-1:3; y&lt;-2:4 x-y; x*y; x/y; x^y ## [1] -1 -1 -1 ## [1] 2 6 12 ## [1] 0.5000000 0.6666667 0.7500000 ## [1] 1 8 81 A fenti műveletek közül a hatványozás végrehajtása tűnhet kicsit szokatlannak, itt ugyanis egy 3 elemű vektort, mint alapot egy 3 elemű másik vektorra, mint kitevőre emeljük. Ha azonban a komponensenkénti végrehajtás szabályát észben tartjuk, akkor világos, hogy az eredményvektor az 12, 23 és a 34 eredménye. A komponensenkénti végrehajtás szabálya logikai operátorokra is érvényes: !c(T,T,F,F) ## [1] FALSE FALSE TRUE TRUE c(T,T,F,F) &amp; c(T,F,T,F) ## [1] TRUE FALSE FALSE FALSE c(T,T,F,F) | c(T,F,T,F) ## [1] TRUE TRUE TRUE FALSE Az operátorokon túl a matematikai függvények is támogatják a vektor paramétert. Ekkor nem egyetlen értékkel térnek vissza, hanem a bemenő vektor minden elemére kiszámolt függvényértékek vektorával: sqrt(c(4,9,16)) ## [1] 2 3 4 log(1:3) ## [1] 0.0000000 0.6931472 1.0986123 A vektorok közötti műveletek legegyszerűbb esetét tekintettük át eddig, azaz két azonos elemszámú vektort adtunk össze, vontunk ki, stb. Ha az operátor két oldalán lévő vektorok elemszáma eltér, akkor az általános szabály az, hogy a rövidebbik vektort az R megismétli mindaddig, míg a hosszabbik vektor elemszámát el nem éri. Ha a rövidebbik vektort nem egész számszor megismételve kapjuk a hosszabb vektort, akkor figyelmeztetést kapunk az R-től, melyben erre a tényre felhívja a figyelmünket, de a kijelölt műveletet az R ennek ellenére végrehajtja. c(1,2)+5 ## [1] 6 7 A fenti példában egy 2 elemű és egy 1 elemű vektort adunk össze. A rövidebb vektort még egyszer megismételve már az (5, 5) vektort kapjuk, így a kijelölt összeadás minden fennakadás nélkül végrehatható. Az eredményvektor az 1+5 és a 2+5 összeadások eredménye lesz. c(1,2)+c(3,4,5) ## [1] 4 6 6 Itt egy 2 elemű és egy 3 elemű vektort adunk össze. A rövidebbik vektort még egyszer megismételve nem használjuk fel minden elemét, így a figyelmezető üzenetet megkapjuk. Az eredményvektor az 1+3, 2+4 és a 1+5 összeadások eredménye. A következő példában már nincs figyelmeztetés: c(1,2)+c(3,4,5,6) ## [1] 4 6 6 8 5.3.3 Függvények vektorokkal Az R egyik legnagyobb erőssége, hogy vektorok elemeivel ciklusok magadása nélkül különböző műveleteket végezhetünk. A legfontosabb vektor alapú függvényeket a következő táblázat tartalmazza: Függvény Leírás Példa Példa értéke max(x) az x vektor legnagyobb eleme max(1:10) 10 min(x) az x vektor legkisebb eleme min(11:20) 11 sum(x) x elemeinek összege sum(1:5) 15 prod(x) x elemeinek szorzata prod(1:5) 120 mean(x) x számtani közepe (mintaátlag) mean(1:10) 5.5 median(x) x mediánja median(1:10) 5.5 range(x) x legkisebb és legnagyobb eleme range(1:10) 1 10 sd(x) az x tapasztalati szórása sd(1:10) 3.027650 var(x) az x tapasztalati varianciája var(1:10) 9.166667 cor(x,y) korreláció x és y között cor(1:10,11:20) 1 5.3.4 Az NA hiányzó érték Gyakorlati esetekben sokszor előfordul, hogy a vektor adott értékét nem ismerjük, de mégis jelentősége miatt jelölnünk kell. Az R-ben az NA értékkel jelölhetjük a hiányzó adatot, amely tetszőleges típusú vektor esetében használható: x&lt;-c(2,NA,4); x [1] 2 NA 4 x&lt;-c(“erős”, NA, “gyenge”); x [1] “erős” NA “gyenge” x&lt;-c(T, NA, FALSE); x [1] TRUE NA FALSE Az NA érték tesztelésére az is.na() függvényt használhatjuk, amelynek a visszatérési értékében lévő vektor ott tartalmaz TRUE értéket, ahol hiányzó adatot találunk. is.na(c(1, NA)) [1] FALSE TRUE Hiányzó értékeket is tartalmazó vektor esetén néhány függvény meglepő eredményt adhat, pl: mean(c(1:10,NA)) [1] NA Ha kíváncsiak vagyunk az NA értéken kívüli elemek átlagára, akkor egy második paramétert is szerepeltetnünk kell a mean() függvényben: mean(c(1:10,NA), na.rm=T) [1] 5.5 Az na.rm argumentum TRUE értéke biztosítja, hogy az átlag számítása során a hiányzó értékeket figyelmen kívül hagyjuk. 3.1.5. Az Inf és a NaN Az R-ben a numerikus műveletek eredménye – a matematikai értelmezéstől sokszor eltérően – vezethet a pozitív vagy negatív végtelen eredményre. Ezeket az Inf és a -Inf szimbólumok jelölik, amelyeket a kifejezésekben mi is felhasználhatunk: 1/0 [1] Inf log(0) [1] -Inf exp(Inf) [1] Inf mean(c(1,2,Inf)) [1] Inf Más esetekben a numerikus kifejezések eredménye nem értelmezhető számként, ezt az R-ben a NaN (’Not a Number’) jelöli. Ilyen kifejezések például: 0/0 [1] NaN Inf-Inf [1] NaN Inf/Inf [1] NaN Egy kifejezés véges vagy végtelen voltát az is.finite() vagy is.infinite() függvényekkel tesztelhetjük. A NaN értékre az is.nan() függvénnyel kérdezhetünk rá. Érdekes megfigyelni, hogy a NaN értékre mind az is.nan() mind az is.na() függvény igazat ad: x&lt;-c(1, 2, NA, NaN, Inf, -Inf) is.na(x); is.nan(x); is.infinite(x); is.finite(x) [1] FALSE FALSE TRUE TRUE FALSE FALSE [1] FALSE FALSE FALSE TRUE FALSE FALSE [1] FALSE FALSE FALSE FALSE TRUE TRUE [1] TRUE TRUE FALSE FALSE FALSE FALSE 5.3.5 Objektumok attribútumai Az R-ben használható objektumok, pl. az eddig vizsgált vektorok, két alapvető attribútummal rendelkeznek. Ez a mód (mode) és a hossz (length), melyek az objektum tárolási szerkezetéről és az elemeinek a számáról adnak tájékoztatást. Ezeket az attribútumokat a mode() és a length() függvények segítségével kérdezhetjük le, ill. állíthatjuk be: x&lt;--1:1; x; mode(x); length(x) ## [1] -1 0 1 ## [1] &quot;numeric&quot; ## [1] 3 mode(x)&lt;-&quot;logical&quot;; length(x)&lt;-5; x ## [1] TRUE FALSE TRUE NA NA Más attribútumokat is rendelhetünk objektumokhoz, melyek speciális jelentéssel bírnak. A names attribútummal például a vektor egyes értékeit nevezhetjük el. (Későbbiekben látjuk a dim, dimnames, row.names, level, class, tsp attribútumok jelentőségét is.) A names attribútum lekérdezhető és beállítható a names() függvénnyel: x&lt;-1:5 names(x)&lt;-c(&quot;elégtelen&quot;, &quot;elégséges&quot;, &quot;közepes&quot;, &quot;jó&quot;, &quot;jeles&quot;) x ## elégtelen elégséges közepes jó jeles ## 1 2 3 4 5 names(x) ## [1] &quot;elégtelen&quot; &quot;elégséges&quot; &quot;közepes&quot; &quot;jó&quot; ## [5] &quot;jeles&quot; A names attribútum egy karakteres vektor, a hozzárendelés után pl. az R egy kiíratásban is felhasználja ezeket a címkéket. További lehetőségek az attribútumok meghatározására az attributes() és az attr() függvénnyek. Az attributes(x) ## $names ## [1] &quot;elégtelen&quot; &quot;elégséges&quot; &quot;közepes&quot; &quot;jó&quot; ## [5] &quot;jeles&quot; parancs az összes attribútumot (az elsődlegeseket nem) kiírja a képernyőre, de ezt a függvényt használva tudjuk az összes attribútumot törölni is (az elsődlegeseket nem törölhetjük): attributes(x)&lt;-NULL attributes(x) ## NULL Az attr() függvényben meg kell adnunk az elérendő attribútum nevét is: attr(x,&quot;names&quot;)&lt;-c(&quot;elégtelen&quot;, &quot;elégséges&quot;, &quot;közepes&quot;, &quot;jó&quot;, &quot;jeles&quot;) attr(x,&quot;names&quot;) ## [1] &quot;elégtelen&quot; &quot;elégséges&quot; &quot;közepes&quot; &quot;jó&quot; ## [5] &quot;jeles&quot; 5.3.6 Vektorok indexelése A vektorok révén egyetlen változónév segítségével tetszőleges számú konstans értékre hivatkozhattunk, így például nagyon egyszerűen mindegyik elemhez hozzáadhattunk 1-et: x&lt;-1:10 x+1 ## [1] 2 3 4 5 6 7 8 9 10 11 Sokszor van szükség azonban arra is, hogy a vektor egyes elemeit külön tudjuk elérni, lekérdezni vagy módosítani. A vektor egy tetszőleges részét, egy vagy több elemét az indexelés művelettel érhetjük el. Az index operátor a szögletes zárójel ([), amit a vektor után kell írnunk. Az index operátorban numerikus, karakteres és logikai vektorok is szerepelhetnek. Nézzük ezeket sorban. Ha létrehozunk egy 10 elemű x vektort a x&lt;-11:20; x ## [1] 11 12 13 14 15 16 17 18 19 20 paranccsal, akkor megfigyelhetjük, hogy az x vektor első eleme 11, a második 12, az utolsó, a tizedik pedig éppen 20. Ebben a felsorolásban az elemek sorszámai (első, második, tizedik) pontosan a vektor indexeit jelentik. A vektor indexelése tehát 1-el kezdődik, ez az első elem indexe, a második elem indexe 2, az utolsó elemé pedig 10. Ha az index operátorba egy ilyen egyszerű sorszámot írunk, akkor a vektor adott indexű elemét érhetjük el: x[1] ## [1] 11 x[2] ## [1] 12 x[10] ## [1] 20 De nem csak lekérdezhetjük, hanem az értékadó operátor segítségével felül is írhatjuk valamelyik elem értékét: x[2]&lt;-100 x[3]&lt;-2*x[2] x ## [1] 11 100 200 14 15 16 17 18 19 20 Itt először a második elemet 100-ra cseréljük, majd a harmadikat a második kétszeresére. A változást látjuk a képernyőn. Ha az x vektort az elemszámánál nagyobb indexszel próbáljuk elérni, akkor NA értéket kapunk: x[11] ## [1] NA Ha negatív skalár értékkel indexelünk, akkor a negatív előjellel megadott sorszámon kívül az összes többi elemet elérhetjük: x&lt;-11:20; x[-3] ## [1] 11 12 14 15 16 17 18 19 20 x[-5]&lt;-0; x ## [1] 0 0 0 0 15 0 0 0 0 0 Vektorokat azonban nem csak numerikus skalárral, hanem két vagy több elemű numerikus vektorokkal is indexelhetünk. Ebben az esetben az indexben felsorolt sorszámoknak megfelelő indexű elemeket érhetjük el: x&lt;-11:20 x[c(1,3,5)]; x[3:6] ## [1] 11 13 15 ## [1] 13 14 15 16 y&lt;-c(3,7); x[y]&lt;-c(100,200); x ## [1] 11 12 100 14 15 16 200 18 19 20 Természetesen indexeléskor negatív értékeket tartalmazó numerikus vektorokat is használhatunk: x&lt;-11:20; x[-seq(from=0, to=10, by=3)]; x[-c(1,10)]; x[-(1:5)] ## [1] 11 12 14 15 17 18 20 ## [1] 12 13 14 15 16 17 18 19 ## [1] 16 17 18 19 20 Egy vektor indexe mindig egész szám, de az R megengedi, hogy tört értékeket szerepeltessünk az index operátorban, ekkor az egész részét veszi az indexeknek (csonkolja őket): x&lt;-11:20; x[2.3]; x[2.8]; x[-2.3]; x[-2.8] ## [1] 12 ## [1] 12 ## [1] 11 13 14 15 16 17 18 19 20 ## [1] 11 13 14 15 16 17 18 19 20 Egy name attribútummal is rendelkező vektort indexelhetünk karakteres vektorral is: x&lt;-1:5 names(x)&lt;-c(&quot;elégtelen&quot;, &quot;elégséges&quot;, &quot;közepes&quot;, &quot;jó&quot;, &quot;jeles&quot;) x[&quot;közepes&quot;]; x[c(&quot;közepes&quot;,&quot;jó&quot;)] ## közepes ## 3 ## közepes jó ## 3 4 Ha tekintünk egy másik példát, x&lt;-c(18,12,20); names(x)&lt;-0:2; x ## 0 1 2 ## 18 12 20 ahol a (0, 1, 2) értékek előfordulási gyakoriságait a (18, 12, 20) elemeket tartalmazó vektorban rögzítjük. Az elemek nevei most is karakteres konstansok, az automatikus konverzióról az R gondoskodik: names(x) ## [1] &quot;0&quot; &quot;1&quot; &quot;2&quot; Az x vektor indexelésénél fontos, hogy megkülönböztessük a numerikus és a karakteres indexeket, az utóbbiaknál mindig idézőjelet kell használnunk: x[1]; x[&quot;1&quot;] ## 0 ## 18 ## 1 ## 12 x[c(1,3)]; x[c(&quot;0&quot;, &quot;2&quot;)] ## 0 2 ## 18 20 ## 0 2 ## 18 20 Az R-ben a vektorokat logikai vektorokkal is indexelhetjük, a TRUE logikai értékkel jelezzük, hogy az adott sorszámú elemet el akarjuk érni: x&lt;-11:15; x[c(TRUE, FALSE, T, T, F)] ## [1] 11 13 14 A fenti példában TRUE szerepel az első, a harmadik és a negyedik pozícióban, így az x vektor 1., 3. és 4. elemeit érhetjük el. Az indexelésre használt logikai vektor elemszáma kisebb is lehet, mint az indexelt vektor hossza, ekkor az R az indexvektor ismétlését használja: x&lt;-11:15; x[c(T,F)]; x[T]; x[F] ## [1] 11 13 15 ## [1] 11 12 13 14 15 ## integer(0) Ha a csupa TRUE értékű vektorral indexelünk, akkor az x vektor összes elemét megkapjuk, ha pedig a csupa FALSE értékkel, akkor az üres vektort kapjuk, az integer(0) az üres, egész értékeket „tartalmazó” vektort jelöli. A logikai index-értékek lehetővé teszik a vektor szűrését is, bizonyos feltételeknek eleget tevő értékek leválogatását. Tekintsük ehhez az x vektort: x&lt;-c(4,7,9,2,8) which(x&lt;5) ## [1] 1 4 A which() függvény bemenő paraméterként egy logikai vektort vár, visszatérési értéke pedig a TRUE logikai értékek indexe lesz. Látható, hogy az x&lt;5 ## [1] TRUE FALSE FALSE TRUE FALSE logikai vektor az 1. és 4. pozícióban tartalmaz logikai igaz értéket. Ha tehát egy adott feltételnek eleget tevő vektorelemek indexére vagyunk kíváncsiak, a which() függvényt használhatjuk. Ha a feltételnek eleget tevő vektor elemeit is el akarjuk érni, akkor vagy a which() által szolgáltatott numerikus értékekkel, x[which(x&lt;5)] ## [1] 4 2 vagy sokkal elegánsabb módon közvetlenül a logikai vektor értékeivel indexelünk: x[x&lt;5] ## [1] 4 2 Természetesen összetett logikai kifejezésekkel is indexelhetünk pl.: which(3&lt;=x &amp; x&lt;=7) ## [1] 1 2 x[3&lt;=x &amp; x&lt;=7] ## [1] 4 7 A vektorok indexelése során az indexoperátor üresen is maradhat, ekkor a vektor összes elemét érhetjük el, továbbá az NA, NaN és NULL értékekkel is indexelhetünk: x&lt;-11:15; x[]; x[NA]; x[NaN]; x[NULL] ## [1] 11 12 13 14 15 ## [1] NA NA NA NA NA ## [1] NA ## integer(0) 5.3.7 Vektorok rendezése Sokszor szükség van egy vektor elemeit növekvő vagy csökkenő sorrendben látni. Az R-ben a vektor elemeit a sort() függvénnyel rendezhetjük: x&lt;-c(1:5,5:3); x ## [1] 1 2 3 4 5 5 4 3 sort(x); sort(x, decreasing=T); rev(sort(x)) ## [1] 1 2 3 3 4 4 5 5 ## [1] 5 5 4 4 3 3 2 1 ## [1] 5 5 4 4 3 3 2 1 A sort() függvény alapértelmezés szerint növekvő sorrendbe rendezi át a bemeneti vektort, ha azonban a decreasing paramétert TRUE-ra állítjuk, csökkenő rendezést kapunk. A rev() függvénnyel, amely a bementi vektor elemit fordított sorrendben sorolja fel, szintén elérhetjük a csökkenő rendezettséget. Ha a sort() függvénnyel átrendezett vektort a továbbiakban fel szeretnénk használni, akkor azt egy újabb objektumban tároljuk. Rossz gyakorlat, ha felülírjuk a kiinduló vektorunkat. A vektor rendezésének másik módja az order() függvényhez kapcsolódik. A visszatérési érték ekkor egy numerikus indexvektor, amellyel a bemenő vektort indexelve rendezett vektort kapunk. x&lt;-c(1:5,5:3); order(x) ## [1] 1 2 3 8 4 7 5 6 x[order(x)]; x[order(x, decreasing=T)]; ## [1] 1 2 3 3 4 4 5 5 ## [1] 5 5 4 4 3 3 2 1 Az order() függvény esetében is használhatjuk a decreasing paramétert, amellyel csökkenő sorrendbe rendezhetjük a vektorunkat. A numerikus vektorokon túl karakteres és logikai vektorokat is sorba rendezhetjük a sort() és order() függvényekkel. 5.3.8 Előre definiált objektumok, nevesített konstansok A R-ben a következő globális változókat használhatjuk, amelyek a base csomagban vektorokként kerültek megvalósításra: pi; T; F ## [1] 3.141593 ## [1] TRUE ## [1] FALSE LETTERS; letters ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; ## [13] &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; ## [25] &quot;Y&quot; &quot;Z&quot; ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; ## [13] &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; ## [25] &quot;y&quot; &quot;z&quot; month.abb; month.name ## [1] &quot;Jan&quot; &quot;Feb&quot; &quot;Mar&quot; &quot;Apr&quot; &quot;May&quot; &quot;Jun&quot; &quot;Jul&quot; &quot;Aug&quot; ## [9] &quot;Sep&quot; &quot;Oct&quot; &quot;Nov&quot; &quot;Dec&quot; ## [1] &quot;January&quot; &quot;February&quot; &quot;March&quot; &quot;April&quot; ## [5] &quot;May&quot; &quot;June&quot; &quot;July&quot; &quot;August&quot; ## [9] &quot;September&quot; &quot;October&quot; &quot;November&quot; &quot;December&quot; "],
["faktorok.html", "5.4 Faktorok", " 5.4 Faktorok A faktor a vektorhoz nagyon hasonló, homogén, egydimenziós adatszerkezet, amelyet elsősorban kategorikus változók értékeinek tárolására használunk. Faktorok esetében csak numerikus és karakteres adattípusokat használhatunk. Numerikus vagy karakteres vektorból a factor() függvény segítségével hozhatunk létre faktort. A faktor az alapértelmezett attribútumokon kívül egy levels attribútumot is tartalmaz, amely a faktor különböző értékeit (szintjeit) sorolja fel. A faktorok class attribútumának értéke pedig factor. x&lt;-c(rep(&quot;A&quot;,3), rep(&quot;B&quot;,4), rep(&quot;C&quot;,3)); x ## [1] &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;C&quot; &quot;C&quot; &quot;C&quot; xf&lt;-factor(x); xf ## [1] A A A B B B B C C C ## Levels: A B C attributes(xf) ## $levels ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; ## ## $class ## [1] &quot;factor&quot; A fenti példában három lehetséges értéket tartalmazó faktort hoztunk létre, amelyek a levels() függvénnyel lekérdezhetők és átírhatók: levels(xf) ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; levels(xf)&lt;-c(0:2); xf ## [1] 0 0 0 1 1 1 1 2 2 2 ## Levels: 0 1 2 levels(xf) ## [1] &quot;0&quot; &quot;1&quot; &quot;2&quot; A szintek meghatározásakor a faktorban eddig nem szereplő értékeket is megadhatjuk: levels(xf)&lt;-c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;); xf ## [1] A A A B B B B C C C ## Levels: A B C D A szintek számáról és azok címkéjéről a factor() függvényben is gondoskodhatunk: factor(1:3, levels=1:5) ## [1] 1 2 3 ## Levels: 1 2 3 4 5 factor(1:3, levels=1:5, labels=&quot;L&quot;) ## [1] L1 L2 L3 ## Levels: L1 L2 L3 L4 L5 factor(1:3, levels=1:5, labels=c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;)) ## [1] A B C ## Levels: A B C D E A faktor létrehozásánál gondoskodhatunk bizonyos értékek kizárásáról, olyan értékekről, amelyeket nem szeretnénk a faktorban felsorolni: factor(c(1:5, NA, 3:6)) ## [1] 1 2 3 4 5 &lt;NA&gt; 3 4 5 6 ## Levels: 1 2 3 4 5 6 Alapértelmezés szerint az NA értéket zárjuk ki a faktor szintjeiből, de ezt megváltoztathatjuk az exclude paraméter használatával: factor(c(1:5, NA, 3:6), exclude=NULL) ## [1] 1 2 3 4 5 &lt;NA&gt; 3 4 5 6 ## Levels: 1 2 3 4 5 6 &lt;NA&gt; factor(c(1:5, NA, 3:6), exclude=c(4, NA)) ## [1] 1 2 3 &lt;NA&gt; 5 &lt;NA&gt; 3 &lt;NA&gt; 5 6 ## Levels: 1 2 3 5 6 Ahogy látjuk a fenti példában, akár az NA értéket is bevonhatjuk a faktor szintjeibe, akár más értékeket is kizárhatunk. Faktorokat a gl() függvénnyel is létrehozhatunk (’generate levels’), ahol a szintek számát és az ismétlések számát kell megadnunk. gl(3,2) ## [1] 1 1 2 2 3 3 ## Levels: 1 2 3 További paraméterként a faktor hosszát és címkéit is meghatározhatjuk: gl(3,2,8) ## [1] 1 1 2 2 3 3 1 1 ## Levels: 1 2 3 gl(3,2,8,labels=c(&quot;gyenge&quot;, &quot;közepes&quot;, &quot;erős&quot;)) ## [1] gyenge gyenge közepes közepes erős erős ## [7] gyenge gyenge ## Levels: gyenge közepes erős "],
["matrixok-es-tombok.html", "5.5 Mátrixok és tömbök", " 5.5 Mátrixok és tömbök Az egydimenziós vektor többdimenziós megfelelője a tömb (array). A tömb a vektorhoz hasonlóan homogén adatszerkezet, amely az alapvető attribútumokon túl a dim attribútummal is rendelkezik. Egy vektort könnyen átalakíthatunk pl. egy 3 dimenziós tömbbé a dim() függvény segítségével: x&lt;-1:8; is.vector(x) ## [1] TRUE dim(x)&lt;-c(2,2,2); is.vector(x); is.array(x) ## [1] FALSE ## [1] TRUE x ## , , 1 ## ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 4 ## ## , , 2 ## ## [,1] [,2] ## [1,] 5 7 ## [2,] 6 8 Az x vektorból egy háromdimenziós tömböt hoztunk létre. Az is.vector() és az is.array() függvények eligazítanak az objektum adatszerkezetével kapcsolatban, vektor ill. tömb paraméter esetén logikai igaz értéket adnak. A tömb kiíratása során az indexoperátorokban szereplő sorszámok segítségével igazodhatunk el az elemek között. A háromdimenziós x tömb dimenziói a sorok, oszlopok és a lapok. A 8 elemet két lapon a ’ , , 1’ és a ’ , , 2’ nevű lapokon két-két sorba ’[1, ]’, ’[2, ]’ és két-két oszlopba ’[ ,1]’, ’[ ,2]’ rendezve sorolja fel az R. A második lapon a 2. sor 1. eleméhez meg kell találnunk a ’ , , 2’ lapot, a ’[2, ]’ sort és a ’[ ,1]’ oszlopot, ami esetünkben a 6. Tömböket az array() függvénnyel is létrehozhatunk: x&lt;-array(data=1:20, dim=c(4,5)); x ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 5 9 13 17 ## [2,] 2 6 10 14 18 ## [3,] 3 7 11 15 19 ## [4,] 4 8 12 16 20 A fenti x tömb dimenzióinak száma 2, az ilyen tömböket mátrixnak is nevezhetjük. Mátrixok létrehozására használhatjuk a matrix() függvényt is: x&lt;-matrix(data=1:20, nrow = 4); x ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 5 9 13 17 ## [2,] 2 6 10 14 18 ## [3,] 3 7 11 15 19 ## [4,] 4 8 12 16 20 Itt az nrow paraméter segítségével irányítjuk az R-et, hogy a sorok és az oszlopok számát meghatározhassa. A matrix() függvényben az ncol paraméter is használható. Láthatjuk, hogy a 20 elemű vektorból az oszlopok mentén hoztuk létre a mátrixot. Ha sorfolytonosan szeretnénk a bemenő vektor elemeiből mátrixot képezni, akkor a byrow paramétert igazra kell állítanunk: matrix(1:12,ncol=4,byrow=T) ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 4 ## [2,] 5 6 7 8 ## [3,] 9 10 11 12 Mátrixok létrehozásához tehát egy adott elemszámú vektor szükséges, de előfordul, hogy a vektor elemeit ismételni kell: matrix(3:5, nrow=2, ncol=3) ## [,1] [,2] [,3] ## [1,] 3 5 4 ## [2,] 4 3 5 matrix(0, nrow=2, ncol=3) ## [,1] [,2] [,3] ## [1,] 0 0 0 ## [2,] 0 0 0 Mátrixot és tömböt karakteres vagy logikai értékekből is építhetünk: matrix(c(&quot;a&quot;,&quot;b&quot;), nrow=2, ncol=3, byrow=T) ## [,1] [,2] [,3] ## [1,] &quot;a&quot; &quot;b&quot; &quot;a&quot; ## [2,] &quot;b&quot; &quot;a&quot; &quot;b&quot; matrix(c(T,F,T), nrow=2, ncol=3, byrow=T) ## [,1] [,2] [,3] ## [1,] TRUE FALSE TRUE ## [2,] TRUE FALSE TRUE A tömbök indexelése nagyon hasonló a vektorok indexelésére, itt is a szögletes zárójel ([]) operátort kell használnunk a tömb egyes elemeinek elérésére. Az egyetlen különbség, hogy mivel itt a dimenziók száma nagyobb mint egy, az egyes dimenzióknak megfelelően, több indexeket kell megadnunk és ezeket vesszővel választjuk el az indexoperátoron belül. Tehát ha x például 3 dimenziós, akkor az x[1,3,2] egy lehetséges példa indexelésére, ahol az első sor, harmadik oszlopában lévő elemre gondolunk, a második lapról. A két dimenziós mátrixok esetén csak a sor és oszlop azonosító indexre van szükségünk (pl. x[2,3]), 4 vagy afeletti dimenziószámok esetén természetesen 4 vagy több vesszővel elválasztott indexre. Az egyes dimenziópozíciókban szereplő indexekre ugyanazok a szabályok érvényesek, mint a vektor esetén. Használhatunk pozitív vagy negatív numerikus skalárokat és vektorokat, de a karakteres és logikai vektorokkal való indexelés is megengedett. Ha egy dimenziópozíciót üresen hagyunk, az továbbra is az összes elemet jelenti abból a dimenzióból: x&lt;-matrix(1:10,nrow=2, ncol=5,byrow=T); x ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 2 3 4 5 ## [2,] 6 7 8 9 10 x[2,3] ## [1] 8 x[2,c(1,4)] ## [1] 6 9 x[,c(1,4)] ## [,1] [,2] ## [1,] 1 4 ## [2,] 6 9 x[,-c(1,4)] ## [,1] [,2] [,3] ## [1,] 2 3 5 ## [2,] 7 8 10 A mátrix indexelés során a kapott elemek elveszthetik a 2 dimenziójukat és egyszerű vektor lehet az eredmény. Ha ezt el akarjuk kerülni, használjuk a drop paramétert hamis értékkel az indexben: x[2,3,drop=F] ## [,1] ## [1,] 8 x[2,c(1,4), drop=F] ## [,1] [,2] ## [1,] 6 9 x[2,, drop=F] ## [,1] [,2] [,3] [,4] [,5] ## [1,] 6 7 8 9 10 x[,3, drop=F] ## [,1] ## [1,] 3 ## [2,] 8 A mátrix sorait és oszlopait elnevezhetjük a rownames() és a colnames() függvényekkel, amelyek mint az látható, a dimnames attribútumot módosítják: rownames(x)&lt;-c(&quot;eset1&quot;, &quot;eset2&quot;) colnames(x)&lt;-paste(&quot;sz.&quot;, 1:5, sep=&quot;&quot;) x ## sz.1 sz.2 sz.3 sz.4 sz.5 ## eset1 1 2 3 4 5 ## eset2 6 7 8 9 10 attributes(x) ## $dim ## [1] 2 5 ## ## $dimnames ## $dimnames[[1]] ## [1] &quot;eset1&quot; &quot;eset2&quot; ## ## $dimnames[[2]] ## [1] &quot;sz.1&quot; &quot;sz.2&quot; &quot;sz.3&quot; &quot;sz.4&quot; &quot;sz.5&quot; Amennyiben egy mátrixnak (vagy egy tetszőleges tömbnek) az egyes dimenziói értékeit elnevezzük, akkor az R megjelenítéskor is használja őket, sőt az indexelés során is felhasználhatjuk: x[&quot;eset1&quot;,&quot;sz.2&quot;] ## [1] 2 x[&quot;eset1&quot;,2] ## [1] 2 x[&quot;eset2&quot;,] ## sz.1 sz.2 sz.3 sz.4 sz.5 ## 6 7 8 9 10 x[&quot;eset1&quot;, c(T,F)] ## sz.1 sz.3 sz.5 ## 1 3 5 Mátrixok (és tömbök) esetén megengedett a mátrixszal történő indexelés is: x&lt;-matrix(1:9, nrow=3); x ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 index.m&lt;-matrix(c(1:3,3:1), nrow=3); index.m ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 2 ## [3,] 3 1 x[index.m]&lt;-0 x ## [,1] [,2] [,3] ## [1,] 1 4 0 ## [2,] 2 0 8 ## [3,] 0 6 9 5.5.1 Számítások a mátrix soraiban és oszlopaiban Ha az üreses hagyjuk a mátrix sor vagy oszlop pozícióját az indexelés során, akkor a mátrix teljes oszlopára vagy sorára tudunk hivatkozni, majd ezekkel, mint vektorokkal műveleteket hajthatunk végre: x&lt;-matrix(1:10,nrow=2, ncol=5,byrow=T); x ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 2 3 4 5 ## [2,] 6 7 8 9 10 mean(x[1,]); var(x[,4]) ## [1] 3 ## [1] 12.5 Négy speciális függvénnyel az oszlopok és sorok összegét és átlagát számíthatjuk ki: rowSums(x); rowMeans(x) ## [1] 15 40 ## [1] 3 8 colSums(x); colMeans(x) ## [1] 7 9 11 13 15 ## [1] 3.5 4.5 5.5 6.5 7.5 Általánosabb megoldás, ha az apply() függvényt használjuk, amelyben a mátrix soraira vagy oszlopaira vonatkozó függvényt mi határozzuk meg. Az apply() első paramétere a mátrix, a második helyen pedig 1 vagy 2 áll, attól függően, hogy a mátrix soraira vagy oszlopaira akarjuk a harmadik paraméterben szereplő függvényt alkalmazni. apply(x, 1, mean); apply(x, 1, var); apply(x, 1, min) ## [1] 3 8 ## [1] 2.5 2.5 ## [1] 1 6 apply(x, 2, mean); apply(x, 2, var); apply(x, 2, min) ## [1] 3.5 4.5 5.5 6.5 7.5 ## [1] 12.5 12.5 12.5 12.5 12.5 ## [1] 1 2 3 4 5 Lehetőség van a mátrix oszlopait úgy összegezni, hogy az egyes sorokat csoportokba soroljuk és az összegzést a csoportokon belül hajtjuk végre. Ha például az x&lt;-matrix(1:12,nrow=4, ncol=3); x ## [,1] [,2] [,3] ## [1,] 1 5 9 ## [2,] 2 6 10 ## [3,] 3 7 11 ## [4,] 4 8 12 mátrix első két sora ill. a második két sora képez egy-egy csoportot, akkor ezt a sorok számával megegyező elemszámú vektor létrehozásával jelezhetjük a következő módon: csoportok&lt;-c(&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;) Magát az oszlopok összegzését az egyes csoportokon a rowsum() függvény végzi: rowsum(x, csoportok) ## [,1] [,2] [,3] ## A 3 11 19 ## B 7 15 23 Amennyiben nem összegzés, hanem más művelet végrehajtása a cél kijelölt csoportokon, akkor a tapply() függvényt használhatjuk. A csoportok meghatározása itt a bemenő x mátrixszal egyező elemszámú faktorok listáján alapul, amit a második paraméterben kell meghatároznunk. A csoportok meghatározásánál a row() és col() függvényeket is használjuk, ezek az x mátrix szerkezetét megtartva minden értékben a sor ill. oszlopsorszámot tartalmazzák: row(x) ## [,1] [,2] [,3] ## [1,] 1 1 1 ## [2,] 2 2 2 ## [3,] 3 3 3 ## [4,] 4 4 4 col(x) ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 1 2 3 ## [3,] 1 2 3 ## [4,] 1 2 3 Ezek alapján rögtön alternatív lehetőséget látunk sorokra és oszlopokra történő műveletvégzésre, hisz a tapply(x, row(x), max) ## 1 2 3 4 ## 9 10 11 12 minden sor maximumát, a tapply(x, col(x), max) ## 1 2 3 ## 4 8 12 pedig minden oszlop maximumát szolgáltatja. Ahhoz azonban, hogy az eredeti célunkat elérjük, nevezetesen, az oszlopok összegét vegyük, úgy, hogy az első két sor és a második két sor külön csoportba tartozik, még a tapply() második paraméterében újabb csoportosító vektort kell megadnunk. Ezt a vektort a list() függvénnyel fűzzük a col(x) csoportosító vektor elé, hisz ez a sorokra fog vonatkozni. A tapply() második paramétere tehát csoportosító vektorokat tartalmazó lista, amelynek az elemeit faktorokra konvertálja az R, mielőtt felhasználja őket. cs.matrix&lt;-matrix(c(&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;), nrow=4, ncol=3); cs.matrix ## [,1] [,2] [,3] ## [1,] &quot;A&quot; &quot;A&quot; &quot;A&quot; ## [2,] &quot;A&quot; &quot;A&quot; &quot;A&quot; ## [3,] &quot;B&quot; &quot;B&quot; &quot;B&quot; ## [4,] &quot;B&quot; &quot;B&quot; &quot;B&quot; tapply(x, list(cs.matrix,col(x)), sum) ## 1 2 3 ## A 3 11 19 ## B 7 15 23 A fenti példában a sorok csoportosítása miatt hoztuk létre a cs.matrix mátrixot. Egyszerűbb azonban ha helyette a csoportok vektort használjuk fel, méghozzá egy mátrixszal indexelt alakját: csoportok[row(x)] ## [1] &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; Ekkor a row(x) mátrixot az alapértelmezett oszlopfolytonos módon véve, éppen a kívánt csoportosító vektort kapjuk, így írhatjuk: tapply(x, list(csoportok[row(x)],col(x)), sum) ## 1 2 3 ## A 3 11 19 ## B 7 15 23 A sum() függvény helyett most már tetszőlegeset választhatunk ebben az általános alakban: tapply(x, list(csoportok[row(x)],col(x)), mean) ## 1 2 3 ## A 1.5 5.5 9.5 ## B 3.5 7.5 11.5 Hasonló eredményt kapunk az aggregate() függvény használatával is: aggregate(x,list(csoportok),sum) ## Group.1 V1 V2 V3 ## 1 A 3 11 19 ## 2 B 7 15 23 Érdekes lehetőség az oszlopokban lévő elemek véletlenszerű átrendezése a sample() függvény segítségével. A sample() függvény a bemenő vektor elemeiből egy véletlen mintát állít elő, alapesetben a bemenet egy permutációját adja: sample(1:5) ## [1] 4 5 3 2 1 Beállíthatjuk az eredményvektor elemszámát is a második paraméterben: sample(1:100,10) ## [1] 62 15 84 65 94 7 71 98 99 56 Ha tehát az oszlopok értékeit egymástól függetlenül fel akarjuk cserélni, írhatjuk a következőt: apply(x,2,sample) ## [,1] [,2] [,3] ## [1,] 2 8 11 ## [2,] 3 5 9 ## [3,] 4 7 10 ## [4,] 1 6 12 5.5.2 Sorok és oszlopok kezelése Létező mátrixot újabb sorokkal és oszlopokkal egészíthetünk ki az rbind() és a cbind() függvényekkel, de vektorokból is építhetünk segítségükkel mátrixot. cbind(1,1:2,1:4) ## [,1] [,2] [,3] ## [1,] 1 1 1 ## [2,] 1 2 2 ## [3,] 1 1 3 ## [4,] 1 2 4 rbind(1,1:2,1:4) ## [,1] [,2] [,3] [,4] ## [1,] 1 1 1 1 ## [2,] 1 2 1 2 ## [3,] 1 2 3 4 Vektor paraméterek esetén, a felsorolt vektorok fogják alkotni az új mátrix oszlopait (cbind() esetén) ill. sorait (rbind() esetén), a rövidebb vektor, ha van ilyen, ismétlődni fog. Új oszloppal vagy új sorral is kiegészíthetjük a mátrixunkat: x&lt;-matrix(1:12,nrow=4, ncol=3); x ## [,1] [,2] [,3] ## [1,] 1 5 9 ## [2,] 2 6 10 ## [3,] 3 7 11 ## [4,] 4 8 12 cbind(-3:0,x,13:16) ## [,1] [,2] [,3] [,4] [,5] ## [1,] -3 1 5 9 13 ## [2,] -2 2 6 10 14 ## [3,] -1 3 7 11 15 ## [4,] 0 4 8 12 16 rbind(-1,x,1) ## [,1] [,2] [,3] ## [1,] -1 -1 -1 ## [2,] 1 5 9 ## [3,] 2 6 10 ## [4,] 3 7 11 ## [5,] 4 8 12 ## [6,] 1 1 1 Tetszőleges pozícióba beszúrhatunk egy oszlopot vagy egy sort: cbind(x,13:16)[,c(1,2,4,3)] ## [,1] [,2] [,3] [,4] ## [1,] 1 5 13 9 ## [2,] 2 6 14 10 ## [3,] 3 7 15 11 ## [4,] 4 8 16 12 rbind(x,-1)[c(1,2,3,5,4),] ## [,1] [,2] [,3] ## [1,] 1 5 9 ## [2,] 2 6 10 ## [3,] 3 7 11 ## [4,] -1 -1 -1 ## [5,] 4 8 12 Hasznos lehetőség összesítő sorok vagy oszlopok mátrixhoz füzése és elnevezése: x&lt;-rbind(x,apply(x,2,mean)) rownames(x)&lt;-c(1:4,&quot;átlag&quot;) x ## [,1] [,2] [,3] ## 1 1.0 5.0 9.0 ## 2 2.0 6.0 10.0 ## 3 3.0 7.0 11.0 ## 4 4.0 8.0 12.0 ## átlag 2.5 6.5 10.5 A sorok vagy oszlopok sorrendjét is megcserélhetjük a mátrixban, valamint ezek törlésére is van lehetőségünk: x&lt;-matrix(1:12,nrow=4, ncol=3); x ## [,1] [,2] [,3] ## [1,] 1 5 9 ## [2,] 2 6 10 ## [3,] 3 7 11 ## [4,] 4 8 12 cbind(x[,c(2,3,1)]) # oszlopcsere ## [,1] [,2] [,3] ## [1,] 5 9 1 ## [2,] 6 10 2 ## [3,] 7 11 3 ## [4,] 8 12 4 rbind(x[c(3,2,4,1),]) # sorcsere ## [,1] [,2] [,3] ## [1,] 3 7 11 ## [2,] 2 6 10 ## [3,] 4 8 12 ## [4,] 1 5 9 cbind(x[,c(1,3)]) # a 2. oszlop törlése ## [,1] [,2] ## [1,] 1 9 ## [2,] 2 10 ## [3,] 3 11 ## [4,] 4 12 rbind(x[c(1,3),]) # az 2. és a 4. sor törlése ## [,1] [,2] [,3] ## [1,] 1 5 9 ## [2,] 3 7 11 "],
["listak.html", "5.6 Listák", " 5.6 Listák Az eddig megismert vektor, faktor, mátrix és tömb adatszerkezet mindegyike homogén, csak azonos típusú értékeket tárolhatunk el bennük. A lista adatszerkezetben egymás után többfajta adatot is felsorolhatunk, sem azok típusára sem azok méretére nincs megszorítás. A list() függvénnyel hozhatunk létre legegyszerűbben listákat, vesszővel elválasztva kell megadnunk a lista elemeit: x&lt;-list(1:10, c(&quot;A&quot;,&quot;B&quot;), c=T); x ## [[1]] ## [1] 1 2 3 4 5 6 7 8 9 10 ## ## [[2]] ## [1] &quot;A&quot; &quot;B&quot; ## ## $c ## [1] TRUE A fenti példában x egy 3 elemű lista, az első eleme egy 10 elemű numerikus vektor, a második eleme egy 2 elemű karakteres vektor, a harmadik eleme pedig egy 1 elemű logikai vektor. A harmadik elemnek ’c’ nevet adtunk, ezt mindegyik listaelem esetén megtehettük volna. Ha a lista értékét megjelenítjük a képernyőn, akkor a listaelemek egymás alatt jelennek meg. Az első két esetben a kettős szögletes zárójelben (’[[]]’) lévő sorszám azonosítja a lista elemeit, a harmadik esetben pedig a listaelem általunk megadott neve a ’$’ után. A listaelemek nevét az x lista names attribútuma tartalmazza, segítségével a többi elemnek is adhatunk értéket: names(x) ## [1] &quot;&quot; &quot;&quot; &quot;c&quot; names(x)[c(1,2)]&lt;-c(&quot;a&quot;,&quot;b&quot;) names(x) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; x ## $a ## [1] 1 2 3 4 5 6 7 8 9 10 ## ## $b ## [1] &quot;A&quot; &quot;B&quot; ## ## $c ## [1] TRUE A lista elemeire a vektoroknál megszokott ’[’ operátor segítségével hivatkozhatunk, ahol numerikus, karakteres és logikai értékeket is megadhatunk: x[1] ## $a ## [1] 1 2 3 4 5 6 7 8 9 10 x[c(2,3)] ## $b ## [1] &quot;A&quot; &quot;B&quot; ## ## $c ## [1] TRUE x[&quot;a&quot;] ## $a ## [1] 1 2 3 4 5 6 7 8 9 10 x[c(T,F,T)] ## $a ## [1] 1 2 3 4 5 6 7 8 9 10 ## ## $c ## [1] TRUE A ’[’ operátorral kapott eredmény minden esetben lista, még akkor is, ha egyetlen elemét érjük el az x listának. Nagyon fontos ettől megkülönböztetni a ’[[’ operátor eredményét, amely a lista valamelyik elemével, annak az értékével tér vissza. Itt nincs mód több listaelem elérésére sem, szokás szerint numerikus vagy karakteres értékkel indexelhetünk. x[[1]] x[[“b”]] x[[3]] A [ operátor alkalmazása helyett a rövidebb $ operátort használhatjuk azoknak a listaelemeknek az elérésére, amelyeket korábban elneveztünk. A lista nevét és az elem nevét fűzzük össze a ’$’ operátorral: x\\(a x\\)b x$c Ha a lista elemét valamelyik módszer segítségével elértük, akkor további indexelés segítségével az elem összetevőit is lekérdezhetjük: x[[&quot;a&quot;]][3:4]; x$a[4:5]&lt;-0; x$c&lt;-F; x ## [1] 3 4 ## $a ## [1] 1 2 3 0 0 6 7 8 9 10 ## ## $b ## [1] &quot;A&quot; &quot;B&quot; ## ## $c ## [1] FALSE A lista mindem elemével a lapply() vagy az sapply() függvény segítségével hajthatunk végre műveletet: lapply(x,length) ## $a ## [1] 10 ## ## $b ## [1] 2 ## ## $c ## [1] 1 sapply(x,length) ## a b c ## 10 2 1 Az lapply() a bemenő lista elemszámával egyező méretű listával tér vissza, melynek értékei az második paraméterben szereplő függvény visszatérési értékei. Az sapply() hasonlóan jár el, de a visszatérési értéke egy vektor. "],
["adattablak-dataframes.html", "5.7 Adattáblák (dataframes)", " 5.7 Adattáblák (dataframes) Az adattábla (dataframe) statisztikai feldolgozás szempontjából az R legfontosabb adatszerkezete. Inhomogén, kétdimenziós szerkezet, amely a lista és a mátrix adatszerkezetek előnyeit hordozza. Sorok és oszlopok alkotják, alapvetően azonos hosszúságú (oszlop)vektorok listájának tekinthető. Adattáblát legegyszerűbben a data.frame() függvénnyel hozhatunk létre, a paraméterben az őt alkotó elemeket kell felsorolni. Ezek lehetnek vektorok, faktorok, mátrixok, listák vagy adattáblák is. Ha a paraméterek hossza nem azonos, akkor a függvény ismétli a rövidebb elemeket, de ez csak egész számszor lehetséges: x&lt;-c(&#39;A&#39;,&#39;B&#39;); y&lt;-6:9; z&lt;-1:8 d&lt;-data.frame(x,y,z); d ## x y z ## 1 A 6 1 ## 2 B 7 2 ## 3 A 8 3 ## 4 B 9 4 ## 5 A 6 5 ## 6 B 7 6 ## 7 A 8 7 ## 8 B 9 8 A példában egy 8 sorból és 3 oszlopból álló adattáblát készítettünk. A data.frame() függvényben nem azonos hosszú vektorokat használtunk az adattábla létrehozására, az automatikus ismétléssel mégis eredményt értünk el. Nézzük, hogyan tekint az R az adattáblára: typeof(d); mode(d); length(d) ## [1] &quot;list&quot; ## [1] &quot;list&quot; ## [1] 3 is.list(d); is.data.frame(d) ## [1] TRUE ## [1] TRUE Az adattáblák típusa és módja is ’list’, a hossza pedig az alkotó (oszlop)vektorok száma. Az adattáblára tehát tekinthetünk úgy, mint egy listára, melynek elemei az adattábla oszlopai lesznek. Az adattábla sorai és oszlopai névvel is rendelkeznek, ezek attribútumokban foglalnak helyet: attributes(d) ## $names ## [1] &quot;x&quot; &quot;y&quot; &quot;z&quot; ## ## $class ## [1] &quot;data.frame&quot; ## ## $row.names ## [1] 1 2 3 4 5 6 7 8 Az str() függvény segítségével az adattábla szerkezetéről kapunk felvilágosítást: str(d) ## &#39;data.frame&#39;: 8 obs. of 3 variables: ## $ x: Factor w/ 2 levels &quot;A&quot;,&quot;B&quot;: 1 2 1 2 1 2 1 2 ## $ y: int 6 7 8 9 6 7 8 9 ## $ z: int 1 2 3 4 5 6 7 8 Láthajuk, hogy a d adattáblánk 8 sort (megfigyelést) és 3 változót (oszlopot) tartalmaz, valamint leolvashatjuk az egyes oszlopok adattípusát is. Megfigyelhetjük, hogy a d$x oszlopot karakteres vektorból faktor típusú változóvá konvertálta a data.frame() függvény. Ezt az alapértelmezett és a statisztikában nagyon hasznos viselkedést az I() függvénnyel tudjuk megakadályozni: str(data.frame(I(x),y,z)) ## &#39;data.frame&#39;: 8 obs. of 3 variables: ## $ x: &#39;AsIs&#39; chr &quot;A&quot; &quot;B&quot; &quot;A&quot; &quot;B&quot; ... ## $ y: int 6 7 8 9 6 7 8 9 ## $ z: int 1 2 3 4 5 6 7 8 Az names attribútum az adattábla oszlopainak, a row.names pedig a sorainak a nevét határozza meg. Ezeket az attribútumokat számos függvénnyel átírhatjuk: a rownames() a sorok nevét a colnames() vagy a names() az oszlopok nevét írja át, de használhatjuk az általános attr() vagy attributes() függvényeket is. A sorok nevének meghatározásánál ügyeljünk arra, hogy azoknak egyedieknek kell lenniük, két azonos sornév nem fordulhat elő. rownames(d)&lt;-paste(1:8, &quot;.szemely&quot;, sep=&quot;&quot;) names(d)&lt;-c(&quot;X&quot;,&quot;Y&quot;,&quot;Z&quot;) d ## X Y Z ## 1.szemely A 6 1 ## 2.szemely B 7 2 ## 3.szemely A 8 3 ## 4.szemely B 9 4 ## 5.szemely A 6 5 ## 6.szemely B 7 6 ## 7.szemely A 8 7 ## 8.szemely B 9 8 Az adattáblák indexelése a mátrixoknál és a listáknál látott módokon is történhet. Ha az adattáblára, mint egy mátrixra tekintünk, használhatjuk a következő hivatkozásokat: d[2,3] ## [1] 2 d[c(2,3),3] ## [1] 2 3 d[c(2,3),] ## X Y Z ## 2.szemely B 7 2 ## 3.szemely A 8 3 d[,3] ## [1] 1 2 3 4 5 6 7 8 d[,3, drop=F] ## Z ## 1.szemely 1 ## 2.szemely 2 ## 3.szemely 3 ## 4.szemely 4 ## 5.szemely 5 ## 6.szemely 6 ## 7.szemely 7 ## 8.szemely 8 Ha az adattáblát listaként indexeljük, akkor érvényesek a következők: d$X ## [1] A B A B A B A B ## Levels: A B d$Y ## [1] 6 7 8 9 6 7 8 9 d$Y[3:5] ## [1] 8 9 6 Az adattábla indexelésénél logikai vektorokat is használhatunk, melyek az adattábla tartalmára vonatkozó relációs kifejezések is lehetnek. Ezzel a módszerrel érhetjük el, hogy az adattábla sorait valamilyen szempont szerint megszűrjük: d[d$Y &lt; 8,] ## X Y Z ## 1.szemely A 6 1 ## 2.szemely B 7 2 ## 5.szemely A 6 5 ## 6.szemely B 7 6 d[d$Y &lt; 8 &amp; d$Z &gt; 2,] ## X Y Z ## 5.szemely A 6 5 ## 6.szemely B 7 6 "],
["feladatok-3.html", "5.8 Feladatok", " 5.8 Feladatok Mi a hasonlóság a következő 3 numerikus érték között: 0xabc, 2748, 0.2748e4. ` "],
["adatok-beolvasasa-es-kiirasa.html", "6 Adatok beolvasása és kiírása", " 6 Adatok beolvasása és kiírása Az R-ben adatokkal dolgozunk, amelyek beolvasására és kiírására az R számos eljárást kínál. Adatokat beolvashatunk a billentyűzetről, a vágóasztalról és külső adatforrásból: állományból vagy adatbázisból is. Az R-ben feldolgozott adatokat a vágóasztalra vagy állományba írhatjuk ki. "],
["adatok-beolvasasa.html", "6.1 Adatok beolvasása", " 6.1 Adatok beolvasása Ebben a könyvben az inline adatbeolvasást és a külső adatállományokból való beolvasást részletezzük. Kisebb adatbázisok, egyszerűbb adatfeldolgozás esetén az adatokat a parancsállományban is elhelyezhetjük, ezt nevezzük sorok közötti, vagy másnéven inline adatbeolvasásának. A szokásos eset azonban a külső adatállományból való adatbeolvasás. 6.1.1 Inline beolvasás Az adatok inline beolvasása azt jelenti, hogy nem külsö állományból, hanem az R parancsállományba gépelt adatokból indulunk ki. Ezek tipikusan a c(), factor() és data.frame() függvények az Alap R-ből, valamint atibble() és tribble() függvények a Tidyverse R-ből. De ide tartozik a read.table() (Alap R) és read_csv() (Tidyverse) függvénycsalád is. A legegyszerűbb adatfeldolgozási feladatok egyetlen változót érintenek, ezek pedig numerikus vektorban vagy faktorban is tárolhatók az R-ben. magassag &lt;- c(132, 143, 129, 145) # 4 óvodás testmagassága cm-ben mean(magassag) ## [1] 137.25 nem &lt;- factor(c(&quot;fiú&quot;, &quot;lány&quot;, &quot;lány&quot;, &quot;fiú&quot;)) # a 4 óvodás neme table(nem) ## nem ## fiú lány ## 2 2 Több változó esetén: d.df &lt;- data.frame(magassag, nem) # data frame létrehozása str(d.df) ## &#39;data.frame&#39;: 4 obs. of 2 variables: ## $ magassag: num 132 143 129 145 ## $ nem : Factor w/ 2 levels &quot;fiú&quot;,&quot;lány&quot;: 1 2 2 1 summary(d.df) ## magassag nem ## Min. :129.0 fiú :2 ## 1st Qu.:131.2 lány:2 ## Median :137.5 ## Mean :137.2 ## 3rd Qu.:143.5 ## Max. :145.0 library(tidyverse) d.tbl &lt;- tibble(magassag, nem) # data frame létrehozása str(d.tbl) ## Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 4 obs. of 2 variables: ## $ magassag: num 132 143 129 145 ## $ nem : Factor w/ 2 levels &quot;fiú&quot;,&quot;lány&quot;: 1 2 2 1 summary(d.tbl) ## magassag nem ## Min. :129.0 fiú :2 ## 1st Qu.:131.2 lány:2 ## Median :137.5 ## Mean :137.2 ## 3rd Qu.:143.5 ## Max. :145.0 d.tbl.2 &lt;- tribble( ~tortenelem, ~matek, ~nem, 3, 2, &quot;fiú&quot;, 2, 4, &quot;fiú&quot;, 3, 5, &quot;lány&quot; ) %&gt;% mutate (nem=as_factor(nem)) str(d.tbl.2) ## Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 3 obs. of 3 variables: ## $ tortenelem: num 3 2 3 ## $ matek : num 2 4 5 ## $ nem : Factor w/ 2 levels &quot;fiú&quot;,&quot;lány&quot;: 1 1 2 summary(d.tbl.2) ## tortenelem matek nem ## Min. :2.000 Min. :2.000 fiú :2 ## 1st Qu.:2.500 1st Qu.:3.000 lány:1 ## Median :3.000 Median :4.000 ## Mean :2.667 Mean :3.667 ## 3rd Qu.:3.000 3rd Qu.:4.500 ## Max. :3.000 Max. :5.000 d.df &lt;- read.table(file = textConnection(&quot; placebo alacsony.alkohol magas.alkohol 5 5 8 10 7 10 7 9 8 3 8 9 5 2 11 7 5 15 11 6 7 2 6 11 3 4 8 5 4 8 6 8 17 6 10 11 &quot;), header=T, sep=&quot;&quot;) summary(d.df) ## placebo alacsony.alkohol magas.alkohol ## Min. : 2.000 Min. : 2.000 Min. : 7.00 ## 1st Qu.: 4.500 1st Qu.: 4.750 1st Qu.: 8.00 ## Median : 5.500 Median : 6.000 Median : 9.50 ## Mean : 5.833 Mean : 6.167 Mean :10.25 ## 3rd Qu.: 7.000 3rd Qu.: 8.000 3rd Qu.:11.00 ## Max. :11.000 Max. :10.000 Max. :17.00 d.tbl &lt;- read_delim(&quot; placebo alacsony.alkohol magas.alkohol 5 5 8 10 7 10 7 9 8 3 8 9 5 2 11 7 5 15 11 6 7 2 6 11 3 4 8 5 4 8 6 8 17 6 10 11 &quot;, col_names=T, delim=&quot; &quot;) summary(d.tbl) ## placebo alacsony.alkohol magas.alkohol ## Min. : 2.000 Min. : 2.000 Min. : 7.00 ## 1st Qu.: 4.500 1st Qu.: 4.750 1st Qu.: 8.00 ## Median : 5.500 Median : 6.000 Median : 9.50 ## Mean : 5.833 Mean : 6.167 Mean :10.25 ## 3rd Qu.: 7.000 3rd Qu.: 8.000 3rd Qu.:11.00 ## Max. :11.000 Max. :10.000 Max. :17.00 "],
["tagolt-szoveges-allomanyok-beolvasasa.html", "6.2 Tagolt szöveges állományok beolvasása", " 6.2 Tagolt szöveges állományok beolvasása 6.2.1 A read.table() család (AR) A leggyakoribb módszer külső állomány beolvasására a read.table() függvény használata. Az adatokat táblázatszerűen tartalmazó, tagolt (adott karakterrel elválasztott) szöveges állományok olvasására használhatjuk. A paraméterekben többek között gondoskodhatunk az első sorban lévő oszlopnevekről (header), az elválasztó karakterről (sep), a tizedesvessző alakjáról (dec) és a hiányzó értékek jelöléséről (na.strings). Érdemes még három további argumentumot észben tartani: a comment, asStringAsFactor és quote. data.file &lt;- &quot;https://github.com/abarik/rdata/raw/master/r_alapok/egyetem.csv&quot; d.df &lt;- read.table(file = data.file, header=T, sep=&quot;;&quot;, dec=&quot;,&quot;) summary(d.df) ## hallgato Height neme ## Min. : 1 Min. :54.0 female:435 ## 1st Qu.:165 1st Qu.:64.0 male :222 ## Median :329 Median :66.0 ## Mean :329 Mean :66.7 ## 3rd Qu.:493 3rd Qu.:70.0 ## Max. :657 Max. :84.0 ## NA&#39;s :10 ## lefekves felkeles Drink ## Min. :-2.500 Min. : 1.000 tej :113 ## 1st Qu.: 0.000 1st Qu.: 7.500 üdítő:178 ## Median : 1.000 Median : 8.500 víz :355 ## Mean : 1.001 Mean : 8.383 NA&#39;s : 11 ## 3rd Qu.: 2.000 3rd Qu.: 9.000 ## Max. : 6.000 Max. :13.000 ## NA&#39;s :3 NA&#39;s :2 A fenti sor egy első sorában oszlopneveket tartalmazó szöveges állomány tartalmát helyezi el a d.df adattáblában. Az állományban az adatokat (és az oszlopneveket is) a pontosvessző (;) választja el, a numerikus értékekben pedig vesszőt használunk a tizedesvessző jelölésére. A paraméterekben leírt feltételeknek megfelelő szöveges állományt egy egyszerű szövegszerkesztővel is létrehozhatjuk, de sokszor egyszerűbb táblázatkezelőt használni, és az abban elkészült, táblázatos formában lévő adatokat megfelelő formátumban exportálni. (Pl. magyar Excel esetén választhatjuk a ’CSV (pontosvesszővel tagolt)’ formátumot). A read.table() függvény helyett használhatjuk a read.csv() és read.csv2() függvényeket is, amelyek csak a paraméterek alapértelmezett értékeiben térnek el az alapfüggvénytől. Ezekben a függvényekben a header alapértelmezetten TRUE, az elválasztó karakter pedig a vessző (csv) ill. a pontosvessző (csv2), valamint a tizedesvessző alakja a pont (csv) ill. a vessző (csv2). Ha tabulátorral tagolt állományt szeretnénk beolvasni, akkor a read.delim() ill. a read.delim2() függvényeket érdemes használni, mert az elválasztó karakter itt alapértelmezés szerint a tabulátor karaktert (”). 6.2.2 A read_delim() függvénycsalád (TR) "],
["fix-szeles-allomanyok.html", "6.3 Fix széles állományok", " 6.3 Fix széles állományok "],
["univerzalis-megoldas.html", "6.4 Univerzális megoldás", " 6.4 Univerzális megoldás "],
["r-objektomok-irasa-es-olvasasa.html", "6.5 R objektomok írása és olvasása", " 6.5 R objektomok írása és olvasása 4.1.3. A read.fwf() függvény A legtöbb beolvasandó szöveges állomány tabulátorral vagy pontosvesszővel tagolt. Ritkábban szükség lehet fix széles mezőket tartalmazó állományok beolvasására is. A read.fwf() függvény width paraméterében kell megadnunk az egyes mezők hosszát. A függvény a megadott mezőhossz értékek alapján egy ideiglenes, tabulátorral elválasztott szöveges állományt hoz létre, amely a read.table() függvénnyel kerül ténylegesen feldolgozásra. &gt; allomany.nev&lt;-tempfile() &gt; cat(file=allomany.nev,“A;B;C”,“123456”,“987654”,sep=“”) &gt; read.fwf(allomany.nev, widths=c(1,2,3),header=T,sep=“;”) A B C 1 1 23 456 2 9 87 654 A fenti példában a tempfile() függvényt használjuk egy a rendszerünkben érvényes ideiglenes állomány nevének meghatározására. A cat() függvénnyel egy 3 soros szöveges állományt hozunk létre. Az első sor pontosvesszővel elválasztott oszlopneveket tartalmaz, a következő két sor pedig 3 fix széles adatmezőt tartalmaz. Ezek hossza rendre 1, 2 és 3 karakternyi. A read.fwf() függvényben pontosan ezeket a mezőhosszakat adjuk meg a width paraméterben. A header paraméterrel jelezzük, hogy az első sor oszlopneveket tartalmaz, a sep paraméter pedig az első sorban használt elválasztó karaktert jelöli. A sep paraméterre csak akkor van szükség, ha oszlopneveket tartalmazó sort is be akarunk olvasni. Láthatjuk, hogy a függvény által visszaadott adattábla 2 sort és 3 oszlopot tartalmaz. 4.1.4. Bináris állományok olvasása Az R-ben számos más statisztikai programcsomag adatállományát is beolvashatjuk. Ezek a foreign csomagban található függvények a &gt; library(foreign) függvényhívás után lesznek elérhetőek, és segítségükkel többek között SPSS, SAS, Minitab, S-PLUS, Stata és Systat állományokat is beolvashatunk. Az összes elérhető függvény listáját a &gt; ls(“package:foreign”) [1] “data.restore” “lookup.xport” “read.arff” “read.dbf” [5] “read.dta” “read.epiinfo” “read.mtp” “read.octave” [9] “read.S” “read.spss” “read.ssd” “read.systat” [13] “read.xport” “write.arff” “write.dbf” “write.dta” [17] “write.foreign” paranccsal kérdezhetjük le. "],
["a-rio-csomag.html", "6.6 A rio csomag", " 6.6 A rio csomag library(rio) data.file &lt;- &quot;https://github.com/abarik/rdata/raw/master/r_alapok/egyetem.csv&quot; d.df &lt;- import(file = data.file, sep=&quot;;&quot;, header=T, dec=&quot;,&quot;) str(d.df) ## &#39;data.frame&#39;: 657 obs. of 6 variables: ## $ hallgato: int 1 2 3 4 5 6 7 8 9 10 ... ## $ Height : num 67 64 61 61 70 63 61 64 66 65 ... ## $ neme : chr &quot;female&quot; &quot;female&quot; &quot;female&quot; &quot;female&quot; ... ## $ lefekves: num -2.5 1.5 -1.5 2 0 1 1.5 0.5 -0.5 2.5 ... ## $ felkeles: num 5.5 8 7.5 8.5 9 8.5 7.5 7.5 7 8.5 ... ## $ Drink : chr &quot;víz&quot; &quot;üdítő&quot; &quot;tej&quot; &quot;víz&quot; ... class(d.df) ## [1] &quot;data.frame&quot; glimpse(d.df) ## Observations: 657 ## Variables: 6 ## $ hallgato &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11... ## $ Height &lt;dbl&gt; 67.0, 64.0, 61.0, 61.0, 70.0, 63.... ## $ neme &lt;chr&gt; &quot;female&quot;, &quot;female&quot;, &quot;female&quot;, &quot;fe... ## $ lefekves &lt;dbl&gt; -2.5, 1.5, -1.5, 2.0, 0.0, 1.0, 1... ## $ felkeles &lt;dbl&gt; 5.5, 8.0, 7.5, 8.5, 9.0, 8.5, 7.5... ## $ Drink &lt;chr&gt; &quot;víz&quot;, &quot;üdítő&quot;, &quot;tej&quot;, &quot;víz&quot;, &quot;üd... data.file &lt;- &quot;https://github.com/abarik/rdata/raw/master/r_alapok/nepesseg.sav&quot; d.df &lt;- import(file = data.file) d.df ## HONAP NEPESSEG ELVESZUL HALAL ## 1 1 10273 10238 13888 ## 2 2 10270 9285 12825 ## 3 3 10267 10105 12516 ## 4 4 10265 9617 11753 ## 5 5 10262 9548 12328 ## 6 6 10260 9717 11839 ## 7 7 10258 9965 11848 ## 8 8 10257 9980 11722 ## 9 9 10256 9844 10968 ## 10 10 10252 9021 12542 ## 11 11 10249 8740 11743 ## 12 12 10246 9538 12917 data.file &lt;- &quot;https://github.com/abarik/rdata/raw/master/r_alapok/pothoff2.xlsx&quot; d.tbl &lt;- import(file = data.file, setclass = &quot;tibble&quot;) d.tbl ## # A tibble: 108 x 5 ## person sex age y agefac ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 F 8 21 8 ## 2 1 F 10 20 10 ## 3 1 F 12 21.5 12 ## 4 1 F 14 23 14 ## 5 2 F 8 21 8 ## 6 2 F 10 21.5 10 ## 7 2 F 12 24 12 ## 8 2 F 14 25.5 14 ## 9 3 F 8 20.5 8 ## 10 3 F 10 24 10 ## # ... with 98 more rows str(d.tbl) ## Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 108 obs. of 5 variables: ## $ person: num 1 1 1 1 2 2 2 2 3 3 ... ## $ sex : chr &quot;F&quot; &quot;F&quot; &quot;F&quot; &quot;F&quot; ... ## $ age : num 8 10 12 14 8 10 12 14 8 10 ... ## $ y : num 21 20 21.5 23 21 21.5 24 25.5 20.5 24 ... ## $ agefac: num 8 10 12 14 8 10 12 14 8 10 ... export(x = d.df, file = &quot;dd.csv&quot;, sep=&quot;;&quot;, dec=&quot;,&quot;) save(d.df, d.tbl, file = &quot;uj.RData&quot;) load(file = &quot;uj.RData&quot;) saveRDS(object = d.tbl, file = &quot;d.tbl.RDS&quot;) dd &lt;- readRDS(file = &quot;d.tbl.RDS&quot;) 4.2. Adatok kiírása Az objektumok értékeinek kiírása könnyebb feladat, mint az adatállományok beolvasása. Egyszerűbb objektumokat a cat() függvénnyel, adattáblákat és mátrixokat a write.table() függvénnyel írhatjuk ki. 4.2.1. A cat() függvény A cat() függvénnyel egyszerű objektumokat írhatunk a képernyőre vagy állományba. A file paraméterben gondoskodhatunk a kimeneti állomány nevéről: &gt; cat(“Helló világ”) Helló világ &gt; cat(“Helló világ”, file=“kiir.txt”) A sep paraméterben az elemi adatokat elválasztó karaktert határozzuk meg, az alapértelmezés a szóköz. &gt; x&lt;-1:5 &gt; cat(x, “”, sep=\") 1 2 3 4 5 A példában az x vektor értékei jelennek meg a képernyőn, majd egy sortörés karakter. Az adatokat a tabulátor jel választja el. "],
["adatok-kiirasa.html", "6.7 Adatok kiírása", " 6.7 Adatok kiírása 4.2.2. A write.table() család Adattáblák és mátrixok kiírására a write.table() függvényt használhatjuk. Az első paraméter a kiírandó objektum neve, a második pedig a kimenti állomány elérési útja. A row.names és a col.names logikai paraméterek szabályozzák, hogy a sor és oszlopnevek szerepeljenek-e a kimeneti állományban. Ezek alapértelmezett értéke TRUE. &gt; xmat&lt;-matrix(1:12,nrow=3) &gt; write.table(xmat,“table.txt”,col.names=F,row.names=F) Mátrixok kiírásánál sokszor a sor- és oszlopnevek kiírásától eltekintünk, adattáblák esetében azonban ez fontos lehet. Arra is van lehetőségünk, hogy az állomány helyett a vágóasztalt válasszuk kimenetnek. Ekkor a &gt; write.table(women,“clipboard”, sep=\", col.names=NA) sorral a vágóasztalra helyezhetjük az adattáblát, amit egy táblázatkezelőbe azonnal beilleszthetünk (CTRL+V). A fenti példa a sorneveket is kiírja, így a helyes beillesztéshez az első sorban, a sor elején egy új oszlopnévre is szükség van. A col.names argumentum NA értéke üres oszlopnév mezőt helyez el az első sorban. A write.table() paramétereinek alapértelmezett értékén változtat a write.csv() és write.csv2() függvény. 5. Adattáblák kezelése Az adatkezelés szempontjából legfontosabb R objektum az adattábla (dataframe). Mint korábban láttuk, a mátrixhoz hasonlóan sorokat és oszlopokat tartalmaz, illetve a listához hasonlóan elemekből, méghozzá azonos hosszúságú oszlopvektorokból, épül fel. Az adattábla kettős eredete jelentősen megkönnyíti az ilyen adatok kezelését. Az adattábla sorai egyedekre (személyek, tárgyak, dolgok, stb.) vonatkozó megfigyelések, az oszlopok pedig a megfigyelt tulajdonságok. A statisztikában úgy mondanánk, hogy az adattáblában az adatmátrixunkat/többdimenziós mintánkat rögzíthetjük, a sorok a mintaelemek, az oszlopok a megfigyelt változók. Az adattábla inhomogén adatszerkezet, oszlopai különböző típusú adatokat is tartalmazhatnak. Jellemzően kvalitatív (nominális és ordinális skálán mért) adatok tárolására a faktort használjuk, kvantitatív (intervallum és arányskálán mért) adatok tárolására a numerikus vektort. Természetesen adattáblában karakteres és logikai vektorok is szerepelhetnek, sőt dátumokat és időpontokat is kezelhetünk az adattáblában. Az adatok adattáblába szervezésénél vezérlő elv, hogy az azonos változóhoz tartozó adatértékek kerüljenek azonos oszlopba. Tekintsünk egy egyszerű kísérletet, ahol arra keressük a választ, hogy a táplálkozás módja befolyásolja-e a vér alvadási idejét. Véletlenszerűen kiválasztunk 24 állatot az egyes diétákhoz (A, B, C, D) és adatainkat papíron a következőképpen rendezzük: A B C D 62 63 68 56 60 67 66 62 63 71 71 60 59 64 67 61 65 68 63 66 68 64 63 59 Az egyes numerikus értékek másodpercben mért véralvadási időket jelentenek. Ahhoz, hogy helyesen hozhassuk létre az adattáblánkat, a következőképpen kell átalakítani a fenti táblázatot. A 62 A 60 A 63 A 59 B 63 B 67 B 71 B 64 B 65 B 66 C 68 C 66 C 71 C 67 C 68 C 68 D 56 D 62 D 60 D 61 D 63 D 64 D 63 D 59 Ezt a táblázatot már rögzíthetjük az R egy adattáblájába. 5.1. Adattáblák létrehozása Korábban már láttuk, hogy a data.frame() függvénnyel hogyan hozhatunk létre adattáblát (3.5. fejezet): a függvény argumentumában az adattáblát alkotó oszlopvektorokat kell felsorolnunk. Állományban rögzített adattábla beolvasására is láttunk példát a 4.1.2. fejezetben: pl. a read.table() függvénnyel adattáblába olvashatjuk adatainkat. További lehetőség a fix() és az edit() függvények használata, melyekkel az Excel munkalapjához hasonló, kényelmes felületen hozhatjuk létre új, vagy módosíthatjuk meglévő adattábláinkat. A függvények a paraméterükben várják a módosítandó adattábla nevét, de az edit() – a fix()-szel ellentétben – nem változtatja meg a paraméter értékét, hanem a módosított adattábla lesz a visszatérési értéke. fix(d) # módosítja d-t d.uj&lt;-edit(d) # d változatlan, a módosítások d.uj-ba kerülnek Az R számos beépített dataset-tel (többnyire adattábla, mátrix, idősor) rendelkezik. A data() függvény segítségével fedezhetjük fel a parancssorból már is elérhető adattáblák nevét és rövid leírását. További információt is kérhetünk egy kiválasztott adattábláról (pl. women): ?women Az alapértelmezetten betöltött csomagok közül a datasets tartalmaz adattáblákat, de számos más csomagban is találhatók dataset-ek, pl: MASS, survival, nlme. A telepített csomagban lévő összes dataset is lekérdezhető következő sorral: data(package = .packages(all.available = TRUE)) 5.2. Adattáblák indexelése Az adattáblák indexelésére a mátrixok és listák indexelési eljárásait is használhatjuk. A 3.5. fejezetben már áttekintettük ezeket a lehetőségeket. A következő példákban a datasets csomag mtcars adattábláját használjuk, amely a parancssorból azonnal elérhető. Az 32 db régi autó fogyasztását és 10 további jellemzőjét tartalmazó adattábla első 10 sorát láthatjuk itt: &gt; mtcars[1:10,] mpg cyl disp hp drat wt qsec vs am gear carb Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 Az adattábla változóinak részletes leírását a következő parancs szolgáltatja: &gt; ?mtcars Indexeléssel elérhetjük adattábla tetszőleges értékét: &gt; mtcars[6,3] [1] 225 &gt; mtcars\\(disp[6] [1] 225 vagy tetszőleges sorát: &gt; mtcars[6,] mpg cyl disp hp drat wt qsec vs am gear carb Valiant 18.1 6 225 105 2.76 3.46 20.22 1 0 3 1 vagy oszlopát: &gt; mtcars[,8] [1] 0 0 1 1 0 1 0 1 1 1 1 0 0 0 0 0 0 1 1 1 1 0 0 0 0 1 0 [28] 1 0 0 0 1 &gt; mtcars\\)am [1] 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 1 1 [28] 1 1 1 1 1 Az adattábla értékeinek egy tetszőleges tartománya is elérhető, ha vektorokkal indexelünk: &gt; mtcars[11:15,c(1,3,8)] mpg disp vs Merc 280C 17.8 167.6 1 Merc 450SE 16.4 275.8 0 Merc 450SL 17.3 275.8 0 Merc 450SLC 15.2 275.8 0 Cadillac Fleetwood 10.4 472.0 0 Ha az indexvektorban használt numerikus értékek sorrendjét felcseréljük, akkor az adattábla oszlopait, esetleg sorait cserélhetjük fel: &gt; mtcars[15:11,c(3,8,1)] disp vs mpg Cadillac Fleetwood 472.0 0 10.4 Merc 450SLC 275.8 0 15.2 Merc 450SL 275.8 0 17.3 Merc 450SE 275.8 0 16.4 Merc 280C 167.6 1 17.8 Amikor az adattábla egyetlen oszlopából válogatunk le adatot, akkor az eredmény nem adattábla, hanem egy vektor lesz. Ezt elkerülhetjük, ha a drop=FALSE argumentumot használjuk: &gt; mtcars[c(2,4,6),8] [1] 0 1 1 &gt; mtcars[c(2,4,6),8,drop=F] vs Mazda RX4 Wag 0 Hornet 4 Drive 1 Valiant 1 Bizonyos esetekben szükség lehet az adattábla sorainak véletlen kiválasztására. Ekkor a sample() függvényt használjuk: &gt; mtcars[sample(1:32,10),] mpg cyl disp hp drat wt qsec vs am gear carb Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 Pontiac Firebird 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 A sample() függvény alapértelmezés szerint visszatevés nélküli választ véletlen értékeket az első paraméterből (esetünkben 32 számból 10-et), de ha a replace=TRUE argumentumot használjuk, akkor visszatevéssel fog választani: &gt; d&lt;-mtcars[sample(11:13,4,replace=T),]; d mpg cyl disp hp drat wt qsec vs am gear carb Merc 280C 17.8 6 167.6 123 3.92 3.44 18.9 1 0 4 4 Merc 450SL 17.3 8 275.8 180 3.07 3.73 17.6 0 0 3 3 Merc 280C.1 17.8 6 167.6 123 3.92 3.44 18.9 1 0 4 4 Merc 450SE 16.4 8 275.8 180 3.07 4.07 17.4 0 0 3 3 A sample() függvény fenti paraméterezése mellett biztosan előfordul sorismétlés az új d adattáblában. Most az 1. és a 3. sor azonos, de mivel a sorok nevének az adattáblában különbözőnek kell lennie a ”Merc 280C” egy ”.1” résszel egészült ki a megismételt 3. sorban. Az sorismétléseket tartalmazó adattáblák kezelésére a duplicated() és a unique() függvényeket használhatjuk. A sorismétlések felderítésére a duplicated() függvényt használjuk: &gt; duplicated(d) [1] FALSE FALSE TRUE FALSE &gt; d[duplicated(d),] mpg cyl disp hp drat wt qsec vs am gear carb Merc 280C.1 17.8 6 167.6 123 3.92 3.44 18.9 1 0 4 4 A sorismétlések eltávolítására a unique() függvényt használhatjuk: &gt; unique(d) mpg cyl disp hp drat wt qsec vs am gear carb Merc 280C 17.8 6 167.6 123 3.92 3.44 18.9 1 0 4 4 Merc 450SL 17.3 8 275.8 180 3.07 3.73 17.6 0 0 3 3 Merc 450SE 16.4 8 275.8 180 3.07 4.07 17.4 0 0 3 3 5.3. A with() és az attach() Az adattáblák változóinak indexelés nélküli elérésére több módszert is nyújt az R. Egyrészt számos statisztikai függvény rendelkezik data argumentummal, amelynek ha egy adattábla nevét adjuk értékül, akkor illető adattábla oszlopneveit mindenfajta indexelés nélkül használhatjuk a statisztikai függvény többi argumentumában. &gt; names(women) [1] “height” “weight” &gt; lm(height~weight,data=women) További lehetőségünk a with() függvény használata, amelyben ha az első argumentumban az adattábla nevét szerepeltetjük, a második argumentumban szereplő kifejezésben nem kell indexelnünk az adattábla változóit: &gt; with(women, lm(height~weight)) Ha több utasítást szeretnénk végrehajtani a with() függvény használata során, akkor a második argumentumban használjunk kapcsos zárójelet ({}), az utasításokat pedig írjuk külön sorba, vagy válasszuk el pontosvesszővel őket. &gt; with(women, {plot(height~weight); abline(lm(height~weight))}) Az attach() függvény használatával is megtakaríthatjuk a változók indexelését. A függvény argumentumában szereplő adattáblát az elérési útba helyezzük, így a névfeloldás során az adattáblánkat is végignézi az R. &gt; names(women) [1] “height” “weight” &gt; height Error: object “height” not found &gt; weight Error: object “weight” not found &gt; attach(women) &gt; height [1] 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 &gt; weight [1] 115 117 120 123 126 129 132 135 139 142 146 150 154 159 164 Az elérési útból a detach() függvénnyel törölhetünk adattáblát (vagy csomagot). &gt; detach(women) &gt; height Error: object “height” not found &gt; weight Error: object “weight” not found Az attach() használatával azonban óvatosnak kell lennünk, mert a munkaterület egyéb változóival könnyen ütközhetnek az adattábla változónevei: &gt; height&lt;-1:10 &gt; attach(women) The following object(s) are masked by .GlobalEnv : height height [1] 1 2 3 4 5 6 7 8 9 10 weight [1] 115 117 120 123 126 129 132 135 139 142 146 150 154 159 164 5.4. Sorok és oszlopok nevei Az adattábla sorait a row.names, az oszlopait a names attribútum használatával nevezhetjük el. A sornevek egymástól különböző, karakteres vagy numerikus egész értékek lehetnek, míg az oszlopnevek csak karakteres adatok. A sor- és oszlopnevek lekérdezésére és beállítására korábban már láttunk példát (3.5. fejezet). Sokszor előfordul, hogy egy adattábla valamely változójának értékeivel szeretnénk a sorokat elnevezni, ill. fordítva, az adattábla sorneveit oszlopvektorban szeretnénk látni. Az adattábla állományból történő beolvasása során a read.table() függvényben a ”row.names=n” argumentum megadásával a szöveges állomány n. oszlopából nyerjük a sorok neveit. Az mtcars adattábla sorneveit a következő parancs segítségével vihetjük be változóba: mtcars2&lt;-data.frame(name=rownames(mtcars),mtcars,row.names=1:32) mtcars2[1:10,] name mpg cyl disp hp drat wt qsec vs am gear carb 1 Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 2 Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 3 Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 4 Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 5 Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 6 Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 7 Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 8 Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 9 Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 10 Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 A fordított irányhoz a következő parancsot kell használnunk: mtcars3&lt;-mtcars2 # új adattábla rownames(mtcars3)&lt;-mtcars3\\(name # sornevek meghatározása mtcars3&lt;-mtcars3[2:11] # a felesleges első oszlop törlése mtcars3[1:10,] mpg cyl disp hp drat wt qsec vs am gear Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 5.5. Rendezés A vektorok rendezésénél már megismertük az order() függvényt (3.1.8. fejezet), amelyet adattáblák rendezésére is használhatunk. Az mtcars adattábla sorait a fogyasztási adatok (mpg változó) alapján növekvő sorrendbe rendezhetjük, ha a sorok indexelésére az order() függvény visszatérési értékét használjuk: order(mtcars\\)mpg) [1] 15 16 24 7 17 31 14 23 22 29 12 13 11 6 5 10 25 30 1 2 [21] 4 32 21 3 9 8 27 26 19 28 18 20 A fenti indexeket a sorkoordináta helyére írva, megkapjuk a rendezett adattáblát (helytakarékosságból az első 10 sorát írjuk ki): mtcars[order(mtcars$mpg)[1:10],] mpg cyl disp hp drat wt qsec vs am gear carb Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 Rendezési szempontnak a sorneveket is használhatjuk: mtcars[order(rownames(mtcars))[1:10],] mpg cyl disp hp drat wt qsec vs am gear carb AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 Rendezésnél egynél több változót is figyelembe vehetünk, ekkor az order() függvényben több változónevet kell felsorolnunk vesszővel elválasztva: mtcars[order(mtcars\\(mpg,mtcars\\)disp)[1:10],c(“mpg”,“disp”)] mpg disp Lincoln Continental 10.4 460.0 Cadillac Fleetwood 10.4 472.0 Camaro Z28 13.3 350.0 Duster 360 14.3 360.0 Chrysler Imperial 14.7 440.0 Maserati Bora 15.0 301.0 Merc 450SLC 15.2 275.8 AMC Javelin 15.2 304.0 Dodge Challenger 15.5 318.0 Ford Pantera L 15.8 351.0 Csökkenő sorrendű rendezéshez használhatjuk az order() függvény ”decreasing=TRUE” argumentumát, vagy a rev() függvényt. Több rendezési szempont esetén ha keverni szeretnénk a rendezési irányokatt, akkor numerikus oszlopvektorok előtt a mínusz (-) jellel fordíthatjuk meg a rendezés irányát csökkenőre. mtcars[order(mtcars\\(mpg,-mtcars\\)disp)[1:10],c(“mpg”,“disp”)] mpg disp Cadillac Fleetwood 10.4 472.0 Lincoln Continental 10.4 460.0 Camaro Z28 13.3 350.0 Duster 360 14.3 360.0 Chrysler Imperial 14.7 440.0 Maserati Bora 15.0 301.0 AMC Javelin 15.2 304.0 Merc 450SLC 15.2 275.8 Dodge Challenger 15.5 318.0 Ford Pantera L 15.8 351.0 5.5. Adattábla szűrése Sokszor előfordul, hogy az adattábla sorait egy vagy több változó (oszlop) értéke szerint szeretnénk leválogatni. Az adattábla indexelése során a sorkoordináta helyén logikai kifejezést szerepeltetünk. Ha például le szeretnénk kérdezni, azokat a sorokat, amelyekben a fogyásztás értéke kisebb mint 15 mérföld/gallon, akkor a következő logikai kifejezést használhatjuk: mtcars\\(mpg&lt;15 [1] FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE [11] FALSE FALSE FALSE FALSE TRUE TRUE TRUE FALSE FALSE FALSE [21] FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE [31] FALSE FALSE A fenti logikai vekorban pontosan azokban a pozíciókban szerepel TRUE érték, amelyik sorban fogyásztás értéke kisebb mint 15 mérföld/gallon. Ha ezt szerpeltetjük a sorkoordináta helyén, a kívánt sorokhoz jutunk: mtcars[mtcars\\)mpg&lt;15,] mpg cyl disp hp drat wt qsec vs am gear carb Duster 360 14.3 8 360 245 3.21 3.570 15.84 0 0 3 4 Cadillac Fleetwood 10.4 8 472 205 2.93 5.250 17.98 0 0 3 4 Lincoln Continental 10.4 8 460 215 3.00 5.424 17.82 0 0 3 4 Chrysler Imperial 14.7 8 440 230 3.23 5.345 17.42 0 0 3 4 Camaro Z28 13.3 8 350 245 3.73 3.840 15.41 0 0 3 4 Több váltózón alapuló feltétel megadásához összetett logikai kifejezést kell írnunk: mtcars[mtcars\\(mpg&lt;15 &amp; mtcars\\)disp&gt;400,] mpg cyl disp hp drat wt qsec vs am gear carb Cadillac Fleetwood 10.4 8 472 205 2.93 5.250 17.98 0 0 3 4 Lincoln Continental 10.4 8 460 215 3.00 5.424 17.82 0 0 3 4 Chrysler Imperial 14.7 8 440 230 3.23 5.345 17.42 0 0 3 4 Adattáblák szűrését egyszerűsíti a subset() függvény, amely az első paraméterében egy adattáblát, második paraméterében pedig a szűrést jelentő logikai kifejezést várja. A fenti szűrés subset() függvény használatával: subset(mtcars, mpg&lt;15 &amp; disp&gt;400) mpg cyl disp hp drat wt qsec vs am gear carb Cadillac Fleetwood 10.4 8 472 205 2.93 5.250 17.98 0 0 3 4 Lincoln Continental 10.4 8 460 215 3.00 5.424 17.82 0 0 3 4 Chrysler Imperial 14.7 8 440 230 3.23 5.345 17.42 0 0 3 4 A subset() függvény egy select argumentumot is tartalmazhat, melynek sgítségével a szűrés eredményében megjelenő oszlopokat határozhatjuk meg: subset(mtcars, mpg&lt;15 &amp; disp&gt;400, select=c(“mpg”,“disp”)) mpg disp Cadillac Fleetwood 10.4 472 Lincoln Continental 10.4 460 Chrysler Imperial 14.7 440 5.6. Hiányzó értékeket tatalmazó sorok eltávolítása Az NA értéket is tartalmazó adattáblánkból az na.omit() függvény használatával távolíthatjuk el azokat a sorokat, amelyekben a hiányzó érték előfordul. data(mtcars) mtcars[c(2,5,7),1]&lt;-NA mtcars[1:10,] mpg cyl disp hp drat wt qsec vs am gear carb Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 Mazda RX4 Wag NA 6 160.0 110 3.90 2.875 17.02 0 1 4 4 Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 Hornet Sportabout NA 8 360.0 175 3.15 3.440 17.02 0 0 3 2 Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 Duster 360 NA 8 360.0 245 3.21 3.570 15.84 0 0 3 4 Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 na.omit(mtcars)[1:10,] mpg cyl disp hp drat wt qsec vs am gear carb Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 5.7. Adattábla oszlopainak transzformálása Számos esetben szükség lehet az adattábla oszlopaiban lévő értéke átalakítására (transzformálására). Az értékeket vagy helyben (ugyanabban az oszlopban) változtatjuk meg, vagy új oszlopként szúrjuk be az adattáblába. Adatok transzformálásához tekintsük a women adattáblát, amely a weight változójában font-ban mért értékeket tartalmaz. Ezt alakítsuk át kg-ban mért adatokká egy új oszlopban: data(women); women height weight 1 58 115 2 59 117 3 60 120 4 61 123 5 62 126 6 63 129 7 64 132 8 65 135 9 66 139 10 67 142 11 68 146 12 69 150 13 70 154 14 71 159 15 72 164 women\\(suly&lt;-round(women\\)weight0.45) women height weight suly 1 58 115 52 2 59 117 53 3 60 120 54 4 61 123 55 5 62 126 57 6 63 129 58 7 64 132 59 8 65 135 61 9 66 139 63 10 67 142 64 11 68 146 66 12 69 150 68 13 70 154 69 14 71 159 72 15 72 164 74 Ugyanezt az eredményt a transform() függvény segítségével is elérhetjük, ahol a subset()-hez hasonlóan némileg egyszerűbben hivatkozhatunk az adattábla változóira. Most alakítsuk át height változót inch-ről cm-re. transform(women,magassag=round(height2.45)) height weight suly magassag 1 58 115 52 142 2 59 117 53 145 3 60 120 54 147 4 61 123 55 149 5 62 126 57 152 6 63 129 58 154 7 64 132 59 157 8 65 135 61 159 9 66 139 63 162 10 67 142 64 164 11 68 146 66 167 12 69 150 68 169 13 70 154 69 172 14 71 159 72 174 15 72 164 74 176 Amennyiben a fenti példákban nem új változónevek az átalakítás célpontjai, hanem már létező oszlopok, akkor helyben végezzük a transzformációt: transform(women,height=height-10) height weight suly 1 48 115 52 2 49 117 53 3 50 120 54 4 51 123 55 5 52 126 57 6 53 129 58 7 54 132 59 8 55 135 61 9 56 139 63 10 57 142 64 11 58 146 66 12 59 150 68 13 60 154 69 14 61 159 72 15 62 164 74 A változók átalakításának másik gyakori esete, amikor az eredetileg folytonos változót kategórikus változóvá alakítjuk. A cut() függvény segítségével numerikus vektorból faktort állíthatunk elő. cut(1:10,3) [1] (0.991,4] (0.991,4] (0.991,4] (4,7] (4,7] (4,7] (4,7] [8] (7,10] (7,10] (7,10] Levels: (0.991,4] (4,7] (7,10] A fenti példában a 10 elemű bemenő vektortból 3 szintű faktort hoztunk létre. Ha az intervallumok határát magunk szeretnénk megadni, akkor a második (breaks) argumentumban egy vektort kell megadnunk: cut(1:10,breaks=c(0,2,10)) [1] (0,2] (0,2] (2,10] (2,10] (2,10] (2,10] (2,10] (2,10] (2,10] (2,10] Levels: (0,2] (2,10] A létrejövő faktor szintjei az intervallumok leírásaiból állnak, természetesen ezeket megvaáltoztathatjuk, csak a labels paramétert kell használnunk: cut(1:10,breaks=c(0,2,7,10),label=c(“gyenge”,“közepes”,“erős”)) [1] gyenge gyenge közepes közepes közepes közepes közepes erős erős [10] erős Levels: gyenge közepes erős Adattáblák esetében a cut() függvény használatára láthatunk egy példát: transform(women,height=cut(height,breaks=c(0,60,70,100), + labels=c(“alacsony”,“közepes”,“magas”))) height weight suly 1 alacsony 115 52 2 alacsony 117 53 3 alacsony 120 54 4 közepes 123 55 5 közepes 126 57 6 közepes 129 58 7 közepes 132 59 8 közepes 135 61 9 közepes 139 63 10 közepes 142 64 11 közepes 146 66 12 közepes 150 68 13 közepes 154 69 14 magas 159 72 15 magas 164 74 "],
["grafika-az-r-ben.html", "7 Grafika az R-ben", " 7 Grafika az R-ben Az R-ben több grafikus rendszer közül választhatunk, amikor az ábráink rajzolásához kezdünk. A hagyományos grafikus rendszer mellett elérhető az ún. grid grafikus rendszer, a trellis/lattice rendszer és a ggplot2 rendszer is. Az egyes rendszerek eltérő megközelítést használnak az ábrák létrehozásához, és természetesen különböző csomagok különböző függvényeit használják. A hagyományos grafikus rendszer az S nyelv grafikus rendszerének implementációja. A magasszintű grafikus függvények a komplett ábrák létrehozásért felelősek, az alacsony szintű függvényekkel pedig kisebb-nagyobb grafikus elemeket helyezhetünk a meglévő ábrára. Mindig “rárajzolunk” a meglévő elemekre, a későbbi módosításra vagy törlésre nincs lehetőségünk. A grid csomagból elérhető grafikus rendszer grafikus primitívek rendkívül gazdag tárháza. Segítségükkel grafikus objektumokat építhetünk, amelyek az ábrától független reprezentációval rendelkeznek, így azok később módosíthatók. A saját koorditáta-rendszerrel rendelkező viewport-ok rendszere tetszőlegesen bonyolult ábrák létrehozását segíti. A grid rendszer maga nem tartalmaz statisztikai rajzfüggvényeket, de számos, a grid csomagra épülő rendszer igen (pl. lattice és ggplot2). A lattice csomag grafikus rendszere az ún. trellis grafikus rendszer megvalósítása R-ben. A hagyományos grafikus rendszerhez képest rendkívül sok fejlesztést tartalmaz. A grid grafikus rendszerre épül, így hordozza annak rugalmasságát. A ggplot2 csomag grafikus rendszere kísérletet tesz arra, hogy a hagyományos és a lattice grafikus rendszer előnyös tulajdonságait ötvözze. Szintén a grid rendszerre épül. A ggplot2 csomag a Tidyverse R része, így a modern R grafikus megjelenítőjének is tekinthetjük. A többi felsorolt grafikus rendszer az Alap R része. Jelen könyvben csak a hagyományos és a ggplot2 grafikus rendszereket ismertetjük. "],
["hagyomanyos-grafika.html", "7.1 Hagyományos grafika", " 7.1 Hagyományos grafika Az Alap R számos eljárást ad a grafikus ábrák létrehozására, sőt saját ábratípusokat is létrehozhatunk. A parancssorba gépelt demo(graphics) vagy demo(persp) függvényhívásokkal képet kaphatunk az R grafikus lehetőségeiről. Az R segítségével grafikus eszközre (graphical device) rajzolhatunk, amely alapértelmezetten a képernyő, de egy adott típusú állomány is lehet. A grafikus (rajz)függvényeink két alapvető csoportba sorolhatók: magas-szintű (high-level) rajzfüggvények, alacsony-szintű (low-level) rajzfüggvények. A hagyományos grafika jellemzője, hogy grafikus paramétereket használ a rajzolás közben. Ezekről a paraméterekről a ?par segítségével kapunk teljes listát, beállításuk és lekérdezésük a par() függvénnyel lehetséges. Például ha a bg= paraméter alapértelmezett fehér értékét megváltoztatjuk szürkére vagy kékre, akkor ugyanaz a rajzfügvény háttérszínben eltérő ábrát fog létrehozni. par(bg=&quot;lightgray&quot;); plot(1:100) par(bg=&quot;lightblue&quot;); plot(1:100) Az alapértelmezett háttérszín értékét ne felejtsük visszaállítani: par(bg=\"white\"). 7.1.1 Grafikus eszközök Az R-ben megnyithatunk egy vagy több grafikus eszközt, ezekből mindig az egyik az aktuális (aktív), amelyre a grafikus függvényeinkkel rajzolhatunk. Az alapértelmezett grafikus eszközünk az R-ben a képernyő egy ablaka (windows), de több állománytípus (pl. jpeg, pdf, postscript) áll rendelkezésre, amelyekben létrehozhatjuk ábráinkat. A grafikus eszközök leírását a ?device paranccsal érhetjük el. Grafikus eszközt a típusuknak megfelelő függvényhívással hozhatunk létre. A következő sorban két windows és egy jpeg típusú grafikus eszközt hozunk létre: windows(); windows(); jpeg(&quot;abra.jpg&quot;) dev.list() Az dev.list() függvénnyel a megnyitott grafikus eszközeink listáját kapjuk meg: az eszköz típusát és azonosítóját látjuk a képernyőn. Az első megnyitott eszközünk 2-es azonosítót kapja. A megnyitott eszközeink egyike az aktuális grafikus eszköz, az utoljára megnyitott eszköz lesz az aktuális. Az aktuális eszközt a dev.cur() függvénnyel kérdezhetjük le, beállítása a dev.set() függvénnyel lehetséges: dev.cur() dev.set(3) dev.cur() A grafikus eszközök bezárását a dev.off() függvény végzi. Paraméter nélkül az aktuális eszközt zárhatjuk be, numerikus paraméterrel pedig az adott sorszámú eszközt. A visszatérési értéke az aktuális grafikus eszköz. A graphics.off() az összes nyitott eszközt bezárja: dev.off() dev.off(2) graphics.off() 7.1.2 Az eszközfelület felosztása Nagyon hasznos lehetőség az R-ben, hogy a rajzterület felosztható különálló részekre (ablakokra), melyek mindegyikére a többitől függetlenül rajzolhatunk. A felosztásra több lehetőségünk is van, ezek nem minden esetben kompatibilisek egymással. A legegyszerűbben a mfrow= vagy mfcol= grafikus paramétereket használhatjuk a felosztásra, egy kételemű numerikus vektor lehet az értékük, amelyek a felosztott ablakok sorainak és oszlopainak a számát határozzák meg. par(mfrow=c(3,2)) A fenti sor hatására egy 3 sorból és 2 oszlopból álló, 6 elkülönült ablakot tartalmazó rajzterületet kapunk. Az mfrow= esetén a felosztás soronként, az mfcol= esetén pedig oszloponként történik. Az aktuális felosztásról a layout.show() függvény ad tájékoztatást: par(mfrow=c(3,2)); layout.show(6) A függvény sorszámokkal azonosítja a különböző rajzterületeket, így azok beazonosíthatók, nagyságuk és elhelyezkedésük az ábráról leolvasható. A fenti felosztás az mfcol= paraméter beállításával is elérhető, de ekkor a rajzterületek kiosztása oszloponként történik: par(mfcol=c(3,2)); layout.show(6) A felosztott rajzterületekre az ábrák rajzolása az azonosítók sorrendjében történik, először az 1-es sorszámú rajzterületre rajzolunk, majd a következő magas-szintű függvényhívás a 2-es sorszámú rajzterületre rajzol, és így tovább. Ritkán előfordul, hogy a fenti sorrendet felül szeretnénk bírálni és azt szeretnénk, hogy a következő magas-szintű függvényünk egy adott (nem a sorrendben következő) rajzterületre vonatkozzon. Ekkor az mfg= paramétert használhatjuk az aktuális rajzterület beállítására. par(mfrow=c(2,3), bg=&quot;lightgreen&quot;) plot(1:10) # ábra az 1,1 pozícióba par(mfg=c(2,3,2,3)) plot(1:10) # ábra a 2,3 pozícióba A fenti példában arról rendelkezünk, hogy a 2. sor 3. oszlopába kerüljön a következő ábra. A 4 elemű numerikus vektor utolsó két értéke csak megismétli a felosztás tényét, miszerint a rajzterület 2 sor és 3 oszlop mentén lett felosztva. A felosztás megszüntetése az egy sorból és egy oszlopból álló “felosztás” beállítását jelenti: par(mfrow=c(1,1)) # felosztás megszüntetése A rajzterület rugalmasabb felosztását teszi lehetővé a layout() függvény, amely a paraméterében szereplő mátrix értékei mentén végzi a felosztást. A rajzterület részei eltérő méretűek is lehetnek, valamint gondoskodhatunk az egymás melletti részek egyesítéséről is. A mfcol= paraméter használatánál szereplő felosztást a következő layout() függvényhívás hajtja végre: layout(matrix(1:6,ncol=2)); layout.show(6) Ha eltérő nagyságú területekre szeretnénk felosztani a rajzunkat, akkor a widths és a heights paraméterekkel állíthatjuk be az oszlopok és a sorok egymáshoz viszonyított arányát. layout(matrix(1:4,ncol=2), widths=c(1,2), heights=c(1,2)) layout.show(4) A felosztás itt egy 2x2-es mátrix alapján történik, ahol a widths= paraméter a két oszlop szélességét állítja be: a második oszlop az első oszlop szélességének kétszerese. A heights= paraméter hasonlóan határozza meg a sorok magasságát. A layout() függvény első paraméterében szereplő mátrix azonos értékeket is tartalmazhat, ekkor egymás melletti rajzterületek összevonására van lehetőségünk: layout(matrix(c(1:3,3),ncol=2), widths=c(1,2), heights=c(1,2)) layout.show(3) A fenti két felosztási módszertől alapjaiban eltérő a split.screen() függvénnyel történő felosztás. split.screen(c(2,1)) A példában 2 sor és 1 oszlop mentén a rajzterületet egy felső és alsó részre osztottuk. Ezek azonosítója a visszatérési értéknek megfelelően 1 és 2. Az azonosítókat felhasználhatjuk az adott rajzterület továbbosztásához: split.screen(c(1,3), screen=2) A 2-es rajzterületet osztjuk 1 sor és 3 oszlop mentén három egyenlő részre, ezek új azonosítóival tér vissza a függvény. A rajzterület kiválasztását a screen() függvénnyel végezzük, paraméterben egy rajzterület azonosítóját kell megadnunk. Rajzterület tartalmát az erase.screen() függvénnyel törölhetjük, a rajzterület felosztásából a close.screen() függvénnyel léphetünk ki. 7.1.3 Az eszközfelület részei Az eszközfelületen egyetlen ábra létrehozásakor a következő részeket különböztethetjük meg: külső margó, ábraterület, belső margó, rajzterület. A 7.1 ábrán belülről kifelé haladva a rajzterület és a belső margó látható, melyek együtt egy olyan ábraterületet alkotnak, amely teljesen kitölti az eszközfelületet. Külső margó alapértelmezés szerint nincs, ezt magunknak kell beállítani. ÁBRA 7.1: Az eszközterület részei (külső margó nélkül) A rajzterületre kerülnek az ábrázolandó pontok, vonalak, görbék, 2 és 3 dimenziós alakzatok. A belső margón foglal helyet az ábra címe és alcíme, a tengelyek feliratai, a beosztások címkéi és maguk a beosztások is. A rajzterület és a belső margó határán helyezkedik el a két tengely, valamint a rajzterületet körbevevő szegély is. A belső margók a mai= (inch-ben mért) és mar= (szövegsorokban mért) paraméterek segítségével kérdezhetők le és állíthatók be. par(c(&quot;mai&quot;, &quot;mar&quot;)) # belső margók lekérdezése ## $mai ## [1] 1.02 0.82 0.82 0.42 ## ## $mar ## [1] 5.1 4.1 4.1 2.1 A kapott értékek rendre az alsó, bal oldali, felső és jobb oldali margókat jelentik. A külső margók az omi= és az oma= paraméterek segítségével kezelhetők és mint láttuk alapértelmezetten nem kerülnek beállításra: par(c(&quot;omi&quot;, &quot;oma&quot;)) # külső margók lekérdezése ## $omi ## [1] 0 0 0 0 ## ## $oma ## [1] 0 0 0 0 Az omi= az inch-ben mért, az oma= pedig a szövegsorban mért margónagyságot határozza meg. Ha 2 szövegsornyira állítjuk mindegyik külső margót par(oma=c(2, 2 ,2, 2)) par(c(&quot;omi&quot;, &quot;oma&quot;)) ## $omi ## [1] 0.4 0.4 0.4 0.4 ## ## $oma ## [1] 2 2 2 2 akkor az eszközfelület a 7.2 ábrának megfelelően épül fel. ÁBRA 7.2: Az eszközterület külső margóval A margókban (külső vagy belső) szöveges információt az mtext() függvénnyel helyezhetünk el. Az side= paraméter a margó kiválasztását jelenti (1=alsó, 2=bal, 3=felső, 4=jobb), a line= paraméterrel a margó szövegsorát adjuk meg (0-val kezdődik), az outer= paraméter pedig a külső vagy belső margó közötti választásról gondoskodik (TRUE=külső margó, FALSE=belső margó). A külső és belső margóba írhatunk a következő parancsokkal: mtext(&quot;Külső margó&quot;, outer=T, line=2) mtext(&quot;Belső margó&quot;, outer=F, line=1) A belső és külső margóba írható szövegsorokról a 7.3 ábra tájékoztatást. Az mtext() függvény line= paramétere határozza meg a szöveg helyét, az adj= paraméter a szöveg igazítását (a tengelyekkel párhuzamos irányban az adj=0 balra igazít, adj=1 jobbra igazít). ÁBRA 7.3: Szövegsorok a külső és belső margón Amennyiben az eszközfelületünket több ablakra osztjuk az alapértelmezett felosztásban az ablakokban egy-egy ábraterület található, amelyek belső margóval és rajzterülettel rendelkeznek (7.4. ábra). ÁBRA 7.4: Szövegsorok a külső és belső margón A külső margó most is hiányzik, de a szokásos grafikus paraméterek segítségével beállíthatjuk, ekkor a 7.5 ábrának megfelelő felosztást kapjuk. ÁBRA 7.5: Szövegsorok a külső és belső margón Természetesen a margókba most is írhatunk tetszőleges szöveget az mtext() függvény segítségével a 7.6 ábrának megfelelően. ÁBRA 7.6: Szövegsorok a külső és belső margón 7.1.4 Magas-szintű rajzfüggvények A magas-szintű rajzfüggvények az aktív grafikai eszközön hoznak létre új ábrát, ami a legtöbbször a régi tartalom törlésével jár. Az ábrához többek között tengelyek, címkék és feliratok tartoznak, amelyek megjelenítéséről a grafikai paraméterekkel gondoskodhatunk. A legtöbbször használt magas-szintű függvények: stripchart() - egydimenziós pontdiagram plot() - kétdimenziós pontdiagram, vonaldiagram hist() - hisztogram barplot() - oszlopdiagram boxplot() - dobozdiagram curve() - függvény ábrázolása pie() - kördiagram 7.1.4.1 A stripchart() függvény A stripchart() legegyszerűbb formájában egyetlen numerikus változó értékeit jeleníti meg, horizontálisan, egymásra rajzolt négyzet pontkarakterekkel. A MASS csomag survey adatbázisát használjuk, és testmagasságokat jelenítünk meg cm-ben mérve. library(MASS) stripchart(x = survey$Height) A horizontális megjelenítést vertikálisra (vertical = T), a négyzetet pedig színezett pontokra cseréljük (pch=21, col=\"blue\", bg=\"lightblue\"), és elvetjük a pontok egymásra rajzolását (method = \"jitter\"). library(MASS) stripchart(x = survey$Height, vertical = T, pch=21, col=&quot;blue&quot;, bg=&quot;lightblue&quot;, method = &quot;jitter&quot;) A pch= paraméter lehetséges értékeiről lesz még szó később. Figyeljük meg, hogy a bg= (és a col= is) más jelentésű a par() argumentumaként, és más jelentésű a magas-szintű függvények argumentumában. Minden magas-szintű függvényben, így a strripchart()-ban is a rajzterületen megjelenített grafikus elem háttérszínét és vonalszínét határozza meg. Ez a két argumentum (bg= és col=) tehát általánosan használható minden más magas-szintű függvényben is. A vertical= és a method= azonban inkább az egydimenziós pontdiagramra jellemző beállítások. Melyek a legfontosabb általános, minden magas-szintű függvényben használható paraméterek: main= Az ábra címe, felül, középen, kielmelten fog megjelenni. sub= Az ábra alcíme, amely az ábra alján jelenik meg. xlab=, ylab= Az x és y tengely felirata, ha elhagyjuk, akkor az ábrázolt objektum nevét olvashatjuk. xlim=, ylim= Az x és y tengelyek ábrázolási tartományát határozzuk meg. Értékeik egy-egy kételemű numerikus vektor, melyek az ábrázolt intervallum alsó és felső határait adják. fg=, bg=,col=, col.axis=, col.lab=, col.main=, col.sub= Az ábra színeinek megadására használt paraméterek. main= Az ábra címe, felül, középen, kielmelten fog megjelenni. sub= Az ábra alcíme, amely az ábra alján jelenik meg. xlab=, ylab= Az x és y tengely felirata, ha elhagyjuk, akkor az ábrázolt objektum nevét olvashatjuk. xlim=, ylim= Az x és y tengelyek ábrázolási tartományát határozzuk meg. Értékeik egy-egy kételemű numerikus vektor, melyek az ábrázolt intervallum alsó és felső határait adják. axes= A tengelyek és a rajzterületet szegélyeinek megjelenítését szabályozzuk. Alapértelmezett értéke TRUE. Ha FALSE értéket adunk, akkor az axis() és a box() függvényekkel a tengelyeket és a szegélyt később is megrajzolhatjuk. bty= A rajzterület szegélyezését állíthatjuk be. Értéke egy karakter lehet, melyek jelentése a következő: \"o\" teljes keretet rajzol \"l\" bal oldalt és lent lesz csak szegély \"7\" fent és jobboldalt rajzol keretet \"c\" alul, baloldalt és felül lesz rajzol szegélyt \"u\" baloldalt, alul és jobboldalt kapunk keretet \"]\" felül, jobboldalt és alul jelenik meg szegély \"n\" nem jelenít meg szegélyt las= Az x és y tengelyek címkéi lehetnek párhuzamosak és merőlegesek a tengelyeikre nézve. A lehetséges eseteknek megfelelően a paraméter értéke lehet: 0= párhuzamosak a tengelyükkel (alapértelmezés) 1= x-re párhuzamos, y-ra merőleges 2= merőlegesek a tengelyükre 3= x-re merőleges, y-ra párhuzamos pch= A kirajzolt pont határozza meg. Értéke vagy egy karakter és ekkor az lesz a megjelenített pont alakja, vagy tipikusan egy skalár 0 és 25 között. cex=, cex.axis=, cex.lab=, cex.main=, cex.sub= Az egyes összetevők relatív mérete family=, font=, font.axis=, font.lab=, font.main=, font.sub= Az egyes összetevők betűtípusa A fenti paraméterek felhasználásával készítsünk egy kicsit szebb ábrát. library(MASS) stripchart(x = survey$Height, vertical = T, pch=21, col=&quot;blue&quot;, bg=&quot;lightblue&quot;, method = &quot;jitter&quot;, main=&quot;Főcím: Testmagasság eloszlása&quot;, sub=&quot;Alcím: Egyetemi hallgatók adatai&quot;, ylab=&quot;Testmagasság (cm)&quot;) A további szépítéshez a korábban megismert grafikus paramétereket kell használnunk. Érdemes megváltoztatni a margót (mar=), a tengelybeosztás címkéinek írásirányát (las=), a tengelyfeliratok és a tengelybeosztás címkéinek távolságát a tengelyektől (mgp=), valamint a beosztások mértetét (tcl=). library(MASS) par(mar=c(3.9, 3, 2, 1)) par(las=1) par(mgp=c(1.9, 0.1, 0)) par(tcl=0.2) stripchart(x = survey$Height, vertical = T, pch=21, col=&quot;blue&quot;, bg=&quot;lightblue&quot;, method = &quot;jitter&quot;, main=&quot;Főcím: Testmagasság eloszlása&quot;, sub=&quot;Alcím: Egyetemi hallgatók adatai&quot;, ylab=&quot;Testmagasság (cm)&quot;) Végül használjuk a szokásos formula argumentumot az x= argumentumban (Height~Sex), amely ebben az esetben a data= argumentum megadását is szükségessé teszi. Az ábrán külön jelennek meg a nők és férfiak testmagasságai. A megjelenítéshez tartozó ylim= paraméteren is változtassunk, az y tengely láthatósági tartományát állítsuk be 140 és 210 közé (ylim=c(140, 210)) library(MASS) par(mar=c(3.9, 3, 2, 1)) par(las=1) par(mgp=c(1.9, 0.1, 0)) par(tcl=0.2) stripchart(x = Height~Sex, data=survey, vertical = T, pch=21, col=&quot;blue&quot;, bg=&quot;lightblue&quot;, method = &quot;jitter&quot;, main=&quot;Főcím: Testmagasság eloszlása&quot;, sub=&quot;Alcím: Egyetemi hallgatók adatai&quot;, ylab=&quot;Testmagasság (cm)&quot;, ylim=c(140, 210)) Egy másik példában egy üzletben eladott kalapácsok számát rögzítettük 25 napon keresztül. A method= argumentum \"stack\" értékével érjük el, hogy egymásra halmazza az azonos pontokat. Ez nagyon jól jöhet diszkrét változók eloszlásának megismeréséhez. library(extrafont) # font_import() # 1x kell végrehajtani # fonts() # tájékozódhatunk az elérhető fontokról loadfonts(device=&quot;win&quot;, quiet = T) par(family=&quot;Times New Roman&quot;) mh &lt;- c(10, 10, 6, 12, 6, 9, 16, 20, 11, 10, 11, 11, 9, 12, 11, 7, 10, 11, 14, 21, 12, 6, 10, 11, 6, 10, 10, 6, 12, 6, 9, 16, 20, 11, 10, 11, 11, 9, 12, 11, 7, 10, 11, 14, 21, 12, 6, 10, 11, 6) stripchart(mh, method=&quot;stack&quot;, pch=21, cex=1.5, offset=2/5, col=&quot;blue&quot;, bg=&quot;lightblue&quot;, axes=F, ylim=c(1,1500000)) axis(1, at = mh) box() title(main=&quot;Eladások&quot;, family=&quot;Calibri&quot;, cex.main=1.3) A fenti ábra elkészítéséhez A fenti ábrában használt globális paramétereket és stripchart() függvényhívásban megjelenő általános argumentumokat minden további ábrában felhasználhatjuk esztétikus grafika létrehozására. Az áttekinthetőség miatt ezeket a továbbiakban mellőzzük, de a publikációban felhasznált ábrák természetesen ezeket a beállításokat nem nélkülözhetik. 7.1.4.2 A plot() függvény A plot() az R legalapvetőbb függvénye ábrák létrehozására. Egyik legegyszerűbb felhasználása, hogy az x és y tengelyek mentén a függvény bemeneti paramétereiben meghatározott értékpárokhoz (mint x és y értékekhez) egy-egy pontot jelenítsen meg az ábrán (7.7 ábra): x&lt;-21:30 y&lt;-51:60 plot(x,y) ÁBRA 7.7: Egyszerű kétdimenziós pontdiagram Az x és y numerikus vektorok 10-10 eleműek, a 7.7 ábrán is 10 pontot látunk. Az első pontnak megfelelő pontkarakter a (21, 51) koordinátájú pontban rajzolódik ki, ezek a koordináták az x és y vektor első elemei. A második kis karika rajzolásához a numerikus vektorok 2. elemeit használja a plot(), ez a (22, 52) koordinátájú pont lesz. A többi 8 pont is hasonlóan, az azonos pozíción lévő vektorelemeknek megfelelő értékpárok alapján jelenik meg az ábrán. A plot() függvény egyetlen vektorral is hívható: y &lt;- 21:30 plot(x) ÁBRA 7.8: étdimenziós pontdiagram egy vektorból A 7.8 ábrán a plot() függvény a bemeneti y vektor alapján jelenít meg 10 pontot. A pontok megjelenítéséhez szükséges két koordináta közül most csak az egyik az y koordináta áll rendelkezésre, ezt éppen az y vektor elemei alkotják. Az x koordináták az y vektor indexeiből állnak, amely egy 10 elemű vektor esetén az 1,2, …, 10 elemeket jelenti. Az első ábrázolt pont koordinátái ennek megfelelően az (1, 21), a második (2, 22) és így tovább, az utolsó (10, 30). A plot() függvény paraméterében a numerikus vektorok helyett faktorok is szerepelhetnek. Ha egyetlen faktorral hívjuk, akkor oszlopdiagramot kapunk, ha faktorral és numerikus vektorral, akkor dobozdiagramot kapunk. Ezeket az eseteket foglalja össze a 7.9 ábra. layout(matrix(1:4, ncol=2, byrow=T)) x &lt;- rnorm(10) y &lt;- rnorm(10) f &lt;- gl(2,3,10) plot(x, main=&quot;Egy változó&quot;, xlab=&quot;Az x vektor indexei&quot;) plot(f, main=&quot;Egy változó&quot;, sub=&quot;Kategorikus változó&quot;, las=1, col=&quot;red&quot;, pch=16, ylim=c(0, 8)) plot(cbind(x,y), main=&quot;Két változó&quot;, ylim=c(-3,3), bty=&quot;l&quot;) plot(y~f, main=&quot;Két változó&quot;, xlab=&quot;Kategórikus változó&quot;, ylab=&quot;Kvantitatív változó&quot;, ylim=c(-3,3)) ÁBRA 7.9: étdimenziós pontdiagram egy vektorból A 7.9 ábra megjelenítéséhez a plot() függvényekben a stripchart()-nál ismertetett paramétereket használtuk. A plot() függvény fontos argumentuma a type=, amelyikkel jelentősen módosíthatjuk azonos adatok esetén is a megjelenítést. A lehetséges értékeket és a hozzájuk tartozó megjelenítést a ?? ábra tartalmazza. layout(matrix(1:9,ncol=3, byrow=T)) x&lt;-1:10; y&lt;-rpois(10,lambda=5); m&lt;-cbind(x=x,y=y-5) plot(m,type=&quot;p&quot;,main=&#39;type=&quot;p&quot;&#39;) plot(m,type=&quot;l&quot;,main=&#39;type=&quot;l&quot;&#39;) plot(m,type=&quot;b&quot;,main=&#39;type=&quot;b&quot;&#39;) plot(m,type=&quot;c&quot;,main=&#39;type=&quot;c&quot;&#39;) plot(m,type=&quot;o&quot;,main=&#39;type=&quot;o&quot;&#39;) plot(m,type=&quot;h&quot;,main=&#39;type=&quot;h&quot;&#39;) plot(m,type=&quot;s&quot;,main=&#39;type=&quot;s&quot;&#39;) plot(m,type=&quot;S&quot;,main=&#39;type=&quot;S&quot;&#39;) plot(m,type=&quot;n&quot;,main=&#39;type=&quot;n&quot;&#39;) 7.1.4.3 A curve() függvény A curve() függvény segítségével egy x-ben változó függvény grafikonját rajzolhatjuk meg. Az első argumentum kifejezése írja le az ábrázolandó függvényt, amely R-beli matematikai függvények nevét is tartalmazhatja. A from= és to= paraméterek határozzák meg a megjelenítés értelmezési tartományát, az n= paraméter pedig, hogy összesen hány behelyettesítés történjen a függvénybe. A ?? ábra tartalmaz néhány példát a curve() függvény használatára. par(mfrow=c(2,2)) curve(12*x**2+3*x-1, from=-10, to=10) curve(sin, from=-5, to=5) curve(sin(x)/x, from=-20, to=20, n=200) curve(dnorm(x,mean=5,sd=2),from=-1, to=11) 7.1.4.4 A hist() függvény A hist() függvény segítségével hisztogramot rajzolhatunk, azaz bizonyos osztályintervallumokhoz tartozó téglalapokat láthatunk egymás mellet, melyek területükkel jelzik az osztályintervallum (relatív)gyakoriságát. Az osztályintervallumok létrehozását a bemenő adatvektor alapján a hist() függvény is végezheti, de tipikusabb a breaks= paraméterrel vezérelni az intervallumok létrehozását. A hist() függvény legfontosabb argumentumai a következők: breaks= Az értéke lehet: skalár (ekkor az osztályintervallumok számát jelenti), numerikus vektor (az osztályintervallumok határai), karaktersorozat (az osztályhatárok megállapítására használt algoritmus neve (“Sturges”, “Scott”, “FD” / “Freedman-Diaconis”) vagy egy saját függvény neve, amely az osztályokat létrehozza. freq= Gyakoriság (TRUE) vagy relatív gyakoriság (FALSE) megjelenítése között választhatunk a paraméter segítségével. Alapértelmezetten TRUE, de ha nem azonos nagyságúk az osztályintervallumok, akkor FALSE lesz az alapértelmezett értéke. right= Az osztályintervallumok bal vagy jobb oldali zártságát szabályozhatjuk vele. Alapértelmezett értéke TRUE, ami jobb oldali zártságot jelent, azaz ezek az értékek még az osztályhoz tartoznak. include.lowest= Amennyiben a right= értéke TRUE és a legkisebb érték az első osztályintervallum bal szélső értéke, akkor az argumentum TRUE értéke esetén (ez az alapértelmezett) az osztályintervallumhoz sorolja a függvény ezt az elemet is. Ha a right= értéke FALSE (jobb oldali nyitottság), akkor mindez a legnagyobb értékre és az utolsó osztály jobb szélső értékére értendő. plot= Ha megváltoztatjuk az alapértelmezett TRUE értéket FALSE-ra, akkor nem történik meg a hisztogram kirajzolása, hanem a visszatérési értékkel (ami egy lista) dolgozhatunk tovább. labels= Az oszlopok tetején (relatív)gyakoriságot jelenít meg. par(mfrow=c(2,2)) x&lt;-c(1,1,1,2,2,3) rx&lt;-rpois(120, lambda=5) hist(x,ylim=c(0,4),labels=T) hist(x,breaks=c(.5,1.5,2.5,3.5),right=TRUE,ylim=c(0,4), labels=T,ylab=&quot;gyakoriság&quot;) hist(x,freq=F,breaks=c(.5,1.5,2.5,3.5),right=TRUE,ylim=c(0,.6), labels=T,ylab=&quot;relatív gyakoriság&quot;,col=rainbow(12)) hist(rx,freq=F,breaks=seq(0,20,3),ylab=&quot;relatív gyakoriság&quot;, col=rainbow(10),main=&quot;Hisztogram&quot;,ylim=c(0,.2)) A boxplot() függvény A boxplot() függvény a hisztogramhoz hasonlóan az adatmegtekintés vizualizálását segíti ún. dobozdiagramok megjelenítésével. A dobozdiagramról a minta terjedelme (legkisebb és legnagyobb értéke), az alsó- és felsőkvartilis, illetve a medián olvasható le. Általában több csoport adatait hasonlítjuk össze a dobozdiagram segítségével. A boxplot() függvény range paraméterével a kiugró értékek kezelését befolyásolhatjuk. par(mfrow=c(2,2)) rx&lt;-rchisq(100,10) boxplot(rx) boxplot(rx,range=0) boxplot(count~spray, data=InsectSprays, col=&quot;lightgray&quot;) boxplot(decrease~treatment, data=OrchardSprays, col=&quot;bisque&quot;) 7.1.4.5 A pie() függvény A kördiagramot a pie() függvénnyel készíthetünk. A radius argumentum a kör sugarát adja meg, a clockwise a körcikkek körbejárási irányát adja meg. par(mfrow=c(2,2)) pie(rep(1,12), col = rainbow(20)) pie(c(2,3,2,3,5), radius=0.9, clockwise = T) pie.sales &lt;- c(0.12, 0.3, 0.26, 0.16, 0.04, 0.12) names(pie.sales) &lt;- c(&quot;Honda&quot;, &quot;Toyota&quot;, &quot;Mazda&quot;, &quot;Volkswagen&quot;, &quot;Egyéb&quot;, &quot;Skoda&quot;) pie(pie.sales) pie(pie.sales, col = gray(seq(0.4,1.0,length=6))) 7.1.4.6 A barplot() függvény A barplot() függvény oszlopdiagram létrehozását teszi lehetővé. Numerikus vektorból vagy mátrixból hozhatunk létre oszlopdiagramot. Használhatjuk a horiz argumentumot, amellyel fekvő vagy álló oszlopdiagramot hozhatunk létre vagy a space-t, amellyel az oszlopok egymás közötti távolságát adhatjuk meg. Mátrix bemenő paraméter esetén az egy oszlopban lévő elemeket egy csoportpa sorolja a box() függvény. A beside argumentum FALSE értéke mellett a csoportok egymás mellett, a csoportok elemei pedig egymás felett jelennek meg. A beside TRUE értéke mellett a csoportok elemei egymás mellett szerepelnek, de a csoportok között nagyobb lesz a távolság. A fentieket szemlélteti a 6.15. ábra. par(mfrow=c(2,2)) barplot(c(1:5,5:1),main=&quot;Vektor argumentum\\nhoriz=F&quot;,col=heat.colors(10)) barplot(rpois(12, lambda=5),main=&quot;Vektor argumentum\\nhoriz=T&quot;,col=heat.colors(12),horiz=T) m&lt;-matrix(1:12,ncol=3); m ## [,1] [,2] [,3] ## [1,] 1 5 9 ## [2,] 2 6 10 ## [3,] 3 7 11 ## [4,] 4 8 12 barplot(m,main=&quot;Mátrix argumentum\\nbeside=F&quot;,col=rainbow(4)) barplot(m,main=&quot;Mátrix argumentum\\nbeside=T, space=c(1,4)&quot;,beside=T, space=c(1,4), col=rainbow(4)) 7.1.5 Alacsony-szintű rajzfüggvények Az alacsony-szintű függvények segítségével meglévő ábráinkhoz adhatunk hozzá elemeket. Szöveget írhatunk a külső vagy belső margóra az mtext(), az ábraterületre pedig a text() függvénnyel. Az ábraterültre pontokat helyezhetünk el points(), vonalakat a lines() és az abline() függvénnyel. Továbbá rajzolhatunk téglalapot a rect(), sokszöget a polygon() függvénnyel. Az ábránkra tengelyeket rajzolhatunk az axis(), szegélyeket a box(), jelmagyarázatot a legend(), címet és alcímet a title() függvénnyel. 7.1.5.0.1 Szöveg elhelyezése Az mtext() függvényben a szöveg helyét a line argumentum határozza meg: az alapértelmezett 0 segítségével a margóra tudunk írni , de kintebb vagy beljebb is tudunk írni a margóhoz képest pozitív vagy negatív érték megadása esetén. A text() függvényben a szöveg helyét a felhasználó koordinátarendszerében értendő x és y argumentum értékei határozzák meg. Mindkét függvény esetében az adj argumentum határozza meg a szöveg igazítását, ami tipikusan 0 és 1 közötti numerikus érték, de a legtöbb grafikus eszközön kibővíthetjük ezt a tartományt. A text() függvény esetében ez a paraméter kételemű vektor is lehet, az első érték az x a második az y irányában határozza meg az igazítást. Az mtext() függvény esetében egyetlen érték is elegendő igazításra, a másik pozíciót a line argumentum értékéből következik. Mindezt a 6.16. ábráról is leolvashatjuk. plot(1:10,xlab=expression(x[y]),ylab=expression(x^y), type=&quot;n&quot;) mtext(&quot;mtext(line= -1,side=3)&quot;,line=-1,side=3) mtext(&quot;mtext(line=1,side=3,adj=0.2)&quot;,line=1,side=3,adj=0.2) mtext(&quot;mtext(line=0,side=4,adj=1)&quot;,line=0,side=4,adj=1) points(2:7,2:7,pch=3, cex=4,col=&quot;red&quot;) text(2,2,&quot;text(2,2)&quot;) text(3,3,&quot;text(6,6,adj=c(0,0))&quot;,adj=c(0,0)) text(4,4,&quot;text(4,4,adj=c(1,0))&quot;,adj=c(1,0)) text(5,5,&quot;text(5,5,adj=c(0,1))&quot;,adj=c(0,1)) text(6,6,&quot;text(6,6,adj=c(1,1))&quot;,adj=c(1,1)) text(7,7,&quot;text(7,7,adj=c(0.5,0.5))&quot;,adj=c(.5,.5)) Az x és y tengely feliratában alsó és felső indexet is használhatunk. Ehhez az expression() függvényt használjuk fel, amellyel kifejezéseket hozhatunk létre az R-ben. Alsó indexek írására a szögletes zárójelet (pl. x[y]), felső indexre a hatványozás jelét (pl. x^y) használhatjuk. A megjelenítendő szöveg betűtípusát is megváltoztathatjuk a font és a family argumentumok segítségével. A font értékei: 1=normál, 2=félkövér,3=dőlt és 4=félkövér/dőlt. A family argumentum egy betűcsalád nevét tartalmazhatja, alapértelmezett értékei a ”serif”, ”sans”, ”mono” és ”symbol” lehetnek. A számítógépen egyéb betűcsaládok a windowsFonts() és a windowFont() függvények használata után lesznek elérhetőek az R-ben. windowsFonts( font.comic = windowsFont(&quot;Comic Sans MS&quot;), font.verdana = windowsFont(&quot;Verdana&quot;),font.trebuchet = windowsFont(&quot;Trebuchet MS&quot;),font.book.antiqua = windowsFont(&quot;Book Antiqua&quot;)) plot(1:10,type=&quot;n&quot;,xlab=&quot;&quot;,ylab=&quot;&quot;) par(cex=1.4) text(2,8,&quot;serif&quot;,family=&quot;serif&quot;,font=1) text(2,6,&quot;sans&quot;,family=&quot;sans&quot;,font=2) text(2,4,&quot;mono&quot;,family=&quot;mono&quot;,font=3) text(2,2,&quot;symbol&quot;,family=&quot;symbol&quot;,font=4) text(8,8,&quot;Comic Sans MS&quot;,family=&quot;font.comic&quot;,font=1) text(8,6,&quot;Verdana&quot;,family=&quot;font.verdana&quot;,font=2) text(8,4,&quot;Trebuchet MS&quot;,family=&quot;font.trebuchet&quot;,font=3) text(8,2,&quot;Book Antiqua&quot;,family=&quot;font.book.antiqua&quot;,font=4) 7.1.5.1 Pontok, vonalak A points() függvény x és y paramétere a megjelenítendő pontok koordinátáit tartalmazzák, míg a lines() függvény ugyanezen paraméterek mellett egyenes szakaszokkal köti össze pontokat. A megjelenítendő pontok alakját a pch, a vonalak típusát pedig a lty paraméter határozza meg. plot(1:10, type=&quot;n&quot;) x&lt;-c(1,2,3,1,2,1,3,2,1,2) points(1:10,x+7, pch=&quot;*&quot;,cex=2) lines(1:10,x+4.4,lty=1) lines(1:10,x+4, lty=2, lwd=1.5) lines(1:10,x+3.6,lty=3, lwd=2) lines(1:10,x+3.2,lty=4, lwd=2.5) lines(1:10,x+2.8,lty=5, lwd=3) lines(1:10,x+2.2,lty=6, lwd=3.5) points(1:10,x, pch=16) lines(1:10,x, lty=5) Egyeneseket az abline() segítségével is létrehozhatunk. Legfontosabb argumentumok az a és a b, amelyek az y tengellyel való metszéspontot és az egyenes meredekséget adják meg. Függőleges és vízszintes egyeneseket is rajzolhatunk a v és h paraméterek megadásával. plot(-4:5,-4:5, type=&quot;n&quot;,xlab=&quot;&quot;,ylab=&quot;&quot;) abline(h=0, v=0, col = &quot;gray60&quot;) text(0.1,0, &quot;abline ( h = 0 )&quot;,col=&quot;gray60&quot;,adj=c(0,-0.1)) text(0,0.1, &quot;abline ( v = 0 )&quot;,col=&quot;gray60&quot;,adj=c(0,-0.1),srt=90) abline(h = -3:4, v = -3:4, col = &quot;lightgray&quot;, lty=3) abline(a=1, b=2, col=&quot;blue&quot;) text(1,3,&quot;abline( 1, 2 )&quot;, col=&quot;blue&quot;,adj=c(-.1,-.1)) abline(a=-2, b=-1, col=&quot;blue&quot;) text(1,-3,&quot;abline( -2, -1 )&quot;, col=&quot;blue&quot;,adj=c(-.1,-.1)) 7.1.5.2 Téglalapok, poligonok, nyilak A rect() függvénnyel téglalapot rajzolhatunk az ábraterületre. A téglalapok bal alsó és jobb felső sarkának x és y koordinátáját kell megadnunk, ezek rendre: xleft, ybottom, xright, ytop. plot(100:500,100:500, type=&quot;n&quot;,xlab=&quot;&quot;,ylab=&quot;&quot;) x&lt;-runif(50)*350 y&lt;-runif(50)*330 rect(100+x, 100+y, 150+x, 170+y, col=rainbow(11,start=.7,end=.1),border=gray(x/400),lwd=x%%10) A polygon() függvény tetszőleges egyenesekkel határolt síkidomok létrehozásáért felelős. Az x és y paraméterében várja a csúcspontok koordinátáit. A lenti példában a vonalak rajzolására használatos segments() függvény is bemutatásra kerül, azt láthatjuk, hogy a polygon() függvény argumentuma, hogyan feleltethető meg a segments() függvény bemenő paraméterének. my_segments&lt;-function(x,y) { i&lt;-1:(length(x)-1) segments(x[i],y[i],x[i+1],y[i+1]) segments(x[length(x)],y[length(x)],x[1],y[1]) } plot(-4:5,-4:5, type=&quot;n&quot;,xlab=&quot;&quot;,ylab=&quot;&quot;) abline(h=0, v=0, col = &quot;gray60&quot;) abline(h = -4:5, v = -4:5, col = &quot;lightgray&quot;, lty=3) x&lt;-c(-4,-1,0) y&lt;-c(1,2,1) polygon(x,y,col=&quot;gray&quot;) y&lt;-y+2 my_segments(x,y) x&lt;-c(1,2,3,4) y&lt;-c(1,2,2,1) polygon(x,y,col=&quot;gray&quot;) y&lt;-y+2 my_segments(x,y) my_func&lt;-function(x) { return (5*dnorm(x,mean=-2,sd=.6)-4) } curve(my_func,from=-4,to=0, add=T) xp&lt;-seq(-4,-2.5,.01) polygon(c(xp,-2.5),c(my_func(xp),-4),col=&quot;red&quot;) curve(my_func(x-5),from=1,to=5, add=T) xp&lt;-seq(2,4,.01) polygon(c(2,xp,4),c(-4,my_func(xp-5),-4),col=&quot;red&quot;) 7.1.5.3 Egyéb kiegészítők Ha ábránk létrehozása során korábban nem gondoskodtunk cím/alcím, tengelyek, szegély vagy jelmagyarázat megrajzolásáról, akkor alacsony-szintű rajzfüggvényekkel utólag is hozzáadhatjuk ezeket a grafikánkhoz. A tilte() függvény fontosabb argumentumai a következők: main, sub Az ábra címének és alcímének meghatározására használjuk. xlab, ylab Tengelyfeliratok hozzáadása. line Az alapértelmezett szövegpozíciót írhatjuk felül, ha meghatározzuk a szövegsor sorszámát. outer Az ábra címét a külső margóra írhatjuk ha TRUE értéket adunk meg. A box() függvény legfontosabb argumentuma: which A bekeretezendő terület meghatározása. Értékei lehetnek: \"plot\" rajzterület szegélyezése \"figure\" ábraterület szegélyezése \"inner\" több ábra esetén az ábraterületeket fogja össze \"outer\" az eszközfelület szegélyezése A tengelyek megjelenítését szabályzó grafikai paraméterek, az axis() függvény használata során: xaxt, yaxt Az x és y tengely kirajzolását tilthatjuk meg, ha ”n” értékkel látjuk el. Alapértelmezett az ”s”, ekkor megrajzolja az illető tengelyt. (Hasonló a szerepe, mint az axes argumentumnak.) mgp=c(3,1,0) A tengely egyes részeinek a rajzterület szélétől mért távolságát meghatározó 3 elemű vektor. Az első érték a tengelyfelirat, a második a tengelycímkék, a harmadik magának a tengely vonalának a margóját adja meg. lab Háromelemű numerikus vektor, amelynek az első két elemével az x és az y tengely beosztásainak a számát határozhatjuk meg. A tényleges osztásszám az általunk megadott értéktől eltérhet. A harmadik elemet nem veszi figyelembe az R. xaxp, yaxp Leginkább lekérdezésre szánt 3 elemű numerikus vektor. Az első és második elem a két szélső beosztás értéket adja, a harmadik elem pedig az osztályok számát. xaxs, yaxs Az alapértelmezett ”r” érték mellett a tengelyek által átfogott intervallum az ábrázolandó adatokból kiszámolt vagy az xlim, ylim paraméterekből kapott intervallumnál 4%-al nagyobb lesz. Pontos egyezéshez az ”i” értéket kell megadnunk. tck, tcl, las, xlim, ylim, log, xlog, ylog Korábban már szerepletek. Az axis() függvény fontos argumentumai: side A rajzolandó tengely helye: 1=lennt, 2=balra, 3=fennt, 4=jobbra.. at=NULL A beosztások helyét határozza meg. Ha az értéke NULL, akkor automatikusan számolja az R, egyébként a megadott numerikus vektor elemeinek megfelelő helyre kerül beosztás. labels A beosztások címkéit határozza meg. Jelmagyarázat többnyire a rajzterületen belül foglal helyet, a pozícióját is a felhasználói koordinátákban kell megadni. A jelmagyarázat létrehozását számos paraméter segíti, de az ábrán szereplő és a jelmagyarázatban használt jelek közötti összhangot nekünk kell megteremteni, az R semmilyen ellenőrzést nem végez ezzel kapcsolatban. A legend() függvény argumentumai: x, y A jelmagyarázat bal felső sarkának a koordinátái a rajzterület koordintáiban mérve. Az x argumentum karakteres értékével az igazítást adhatjuk meg: “bottomright”, “bottom”, “bottomleft”, “left”, “topleft”, “top”, “topright”, “right” and “center” legend A jelmagyarázat szövegét tartalmazó karakteres vektor. fill, lty, lwd, pch A jelmagyarázat szövegét és az ábrán használt jeleket összekötő szimbólumok létrehozására használható argumentumok. inset=0 Ha kulcsszavakat használunk az igazításra, akkor a margótól mért távolságot itt adhatjuk meg. merge Ha pontokat és vonalakat is használunk a jelmagyarázatban, akkor TRUE érték mellett ezeket kombinálja a megjelenítéskor. horiz=FALSE A jelmagyarázat tájolását befolyásoló logikai paraméter. ncol=1 A jelmagyarázat oszlopainak a számát határozza meg. text.col, bg A szöveg színe és a háttérszín jelmagyarázatban. op&lt;-par() par(oma=c(.5,.5,2,.5)) par(mfrow=c(2,2)) x&lt;-rnorm(10) plot(x,main=\"“,axes=F,xlab=”“,ylab=”“,col=gray(0.7)) text(5.5,0,”Alapértelmezett“,font=2) title(main=”Cím a külső margón“,outer=T,line=0.2) title(main=”Cím a belső margón“) title(sub=”ALCÍM“) title(xlab=”x“,ylab=”y“) box(”outer“,lty=1,col=grey(.2)) box(”inner“,lty=2,col=grey(.4)) box(”figure“,lty=3,col=grey(.6)) box(”plot\",lty=4,col=grey(.8)) axis(1, at=1:10);axis(2) par(xaxs=“i”) par(yaxs=“i”) par(mgp=c(2,.5,0)) plot(x,main=‘xaxs=“i”,yaxs=“i”,mgp=c(2,.5,0)’,axes=F, + xlab=“axis(1,at=1:10,tcl=.3)”,ylab=\"“) box(”plot\",lty=4,col=grey(.8)) axis(1,at=1:10,tcl=.3) par(xaxs=“r”) par(yaxs=“r”) par(mgp=c(3,1,-.2)) plot(x,main=‘xaxs=“r”,yaxs=“r”,mgp=c(3,1,-.2)’,axes=F,xlab=“axis(1,at=3:8,labels=LETTERS[1:6])”,ylab=\"“) box(”plot\",lty=4,col=grey(.8)) axis(1,at=3:8,labels=LETTERS[1:6]) axis(2) axis(4) par(mgp=c(3,1,0)) par(mar=c(1,1,1,1)) plot(1:10,main=\"“,axes=F,xlab=”“,ylab=”“,type=”n“) box(”figure“,lty=3,col=grey(.6)) box(”plot“,lty=4,col=grey(.8)) legend(”topleft“,LETTERS[1:3],lw=1:3,inset=.1) legend(”top“,LETTERS[1:3],lty=1:3,inset=.1) legend(”topright“,LETTERS[1:3],lty=1:3,pch=0:3,inset=.05) legend(”right“,LETTERS[1:3],lw=1:3,pch=0:3) legend(”bottomright\",LETTERS[1:3],fill=2:4,text.col=2:4) legend(1,7, as.character(0:25), pch = 0:25,ncol=4,cex=1.2) par(op) 6.22. ábra 7.1.6 Interaktív grafikus függvények Az R hagyományos grafikus rendszere elsősorban statikus ábrák létrehozását támogatja, a kész grafikán további interaktív műveletekre csak korlátozottan van lehetőség. Ezek közül most a locator() és az identify() függvényeket tekintjük át. A locator() függvény lehetővé teszi, hogy a felhasználó a rajzterületen az egér bal gombjával kijelöljön egy vagy több pontot. A függvény visszatérési értéke egy lista, amely a megjelölt pontok x és y koordinátáit sorolja fel. legend(locator(1), as.character(0:25), pch = 0:25) A locator() függvény fontosabb argumentumai: n= A meghatározandó pontok maximális számát adhatjuk meg. Alapértelmezetten 512 pont helyét kaphatjuk meg. type= Értéke az ”n”, ”p”, ”l” vagy ”o” karakter valamelyike lehet. Az alapértelmezett ”n” esetében az egérkattintás után nem történik megjelenítés, míg ”p” és ”o” hatására egy pont fog megjelenni, ”l” vagy ”o” estén pedig vonal fogja összekötni a megjelölt helyeket. Az identify() függvény a rajzterületen megjelenő adatpontokhoz rendel címkét. A locator() függvényhez hasonlóan az egér bal gombjával itt is ki kell jelölni egy pontot a rajzterületen, majd a függvény a megjelölt ponthoz legközelebb lévő adatponthoz rendel egy címkét. Az indentify() függvény visszatérési értéke az azonosított adatpontok indexe. library(MASS) plot(mammals$body, mammals$brain, log=&quot;xy&quot;) identify(mammals$body, mammals$brain, row.names(mammals), n=10) Az identify() függvény fontosabb argumentumai: x=, y= Numerikus vektorok, amelyek az ábra adatpontjainak x és y koordinátáit határozzák meg. labels= Karakteres vektor, amely egyes adatpontok címkéit tartalmazza. Az x és y argumentumokkal azonos hosszú vektor, alapértelmezetten sorszámokat tartalmaz. pos=FALSE Ha FALSE az értéke, akkor a függvény az azonosított adatpontok indexével fog visszatérni. Ha TRUE, akkor egy listával, amely az ind elemében az indexeket, pos elemében pedig a címke adatponthoz viszonyított helyét tartalmazza (1=lennt, 2=balra, 3=fennt, 4=jobbra, ill. 0=ekkor az atpen=TRUE volt) n= A megjelelölendő pontok száma. plot=TRUE Logikai érték, amely ha TRUE (ez az alapértelmezett), akkor megjelenít címkéket, egyébként nem. atpen=FALSE A címke pozíciója TRUE érték esetén az egérkattintás helye lesz, FALSE esetén automatikusan kerül meghatározásra. offset=0.5 A címke és az adatpont távolsága. A numerikus érték a karakterszélességhez mért. Az atpen=FALSE esetén nem használja az R. tolarence=0.25 Inch-ben mért numerikus érték, amely az egérkattintás és a „közeli” adatpont közötti maximális távolságot jelenti. "],
["a-modern-grafika-ggplot2.html", "7.2 A modern grafika (ggplot2)", " 7.2 A modern grafika (ggplot2) A grafika komponensei: adat: maga az adatbázis, amely az összes szükséges változót tartalmazza geom: az ábrán megjelenő alakzatok: pontok, vonalak, oszlopok "],
["az-r-programozasa.html", "8 Az R programozása", " 8 Az R programozása Ebben a fejezetben néhány haladó fogalmat beszélünk meg, ezekre a mindennapos adatelemzés során ritkán van szükség. Az leírtak azonban segítik készen kapott R kódok megértését, és esetleges módosítását. A három legfontosabb programozási elem a szekvencia, a feltételes utasításvégrahajtás és a ciklus. A szekvenciát már ismerjük, mégha nem is neveztük meg, hiszen utasítások egymás utáni végrehajtását jelenti a parancsállományoban, fentről lefelé, sorról-sorra. Például ha kíváncsiak vagyunk a legalacsonyabb és a legmagasabb Csillagok háborúja szereplőkre, akkor 3 sor egymás utána kiértékelése ereményre vezethet: library(dplyr) starwars[order(starwars$height, decreasing = F)[1], c(&quot;name&quot;, &quot;height&quot;)] ## # A tibble: 1 x 2 ## name height ## &lt;chr&gt; &lt;int&gt; ## 1 Yoda 66 starwars[order(starwars$height, decreasing = T)[1], c(&quot;name&quot;, &quot;height&quot;)] ## # A tibble: 1 x 2 ## name height ## &lt;chr&gt; &lt;int&gt; ## 1 Yarael Poof 264 Az R értelmező az utasítások egymás utáni kiértékelését végzi. Az utasításokat újsor karakter vagy pontosvessző választhatja el. A szintaktikailag helyes utasítások kiértékelése mindig egy értéket eredményez, ez lesz az utasítás értéke. Még akkor is rendelkezik értékkel az utasításunk, ha az nem jelenik meg a parancssorban, például az értékadó utasítás értéke a jobb oldali kifejezés értéke. Ezért írhatjuk a következő parancsot: y &lt;- x &lt;- 10 x; y ## [1] 10 ## [1] 10 Az R a többi programozási nyelvhez hasonlóan a bonyolultabb problémák megoldására speciális szerkezeteket is biztosít. Alapvetően két feladatot kell megoldani, a feltételes programvégrehajtást és az utasítások többszöri végrehajtását. "],
["blokk-utasitas.html", "8.1 Blokk utasítás", " 8.1 Blokk utasítás Az utasítások csoportosíthatók (blokkba szervezhetők) a kapcsos zárójelek ({ és }) segítségével következő módon: { utasítás-1; utasítás-2; …; utasítás-n } vagy { utasítás-1 utasítás-2 … utasítás-n } Az így kapott szerkezet a továbbiakban egyetlen utasításnak tekinthető, és tetszőleges helyen, ahol utasítás egyáltalán megjelenhet, a fenti blokk utasítás is szerepelhet. A blokk utasításban az elválasztásra használhatjuk az újsort is. A blokk utasítás értéke a benne szereplő utolsó utasítás értéke lesz. y &lt;- { x &lt;- 10 x+1 } y ## [1] 11 "],
["felteteles-utasitasok.html", "8.2 Feltételes utasítások", " 8.2 Feltételes utasítások Utasítások feltételtől függő végrehajtására a feltételes utasítások használhatók. Ha egy feltétel teljesül, akkor végrehajtjuk az utasítás-1 programrészt, ha nem teljesül, akkor valami más utasítás-2 programrészt hajtunk végre. A feltételes utasítás általános alakja a következő: if (feltétel) utasítás-1 else utasítás-2 A feltétel egy logikai értéket szolgáltató kifejezés, amely ha TRUE értéket vesz fel, akkor a teljes if utasítás értéke az utasítás-1, ha pedig FALSE-t, akkor az utasítás2 értéke lesz. Vagyis, igaz feltétel esetén az utasítás1 programrészt, hamis esetben pedig az utasítás2 programrészt hajtjuk végre. A feltétel lehet numerikus érték is, ekkor a szokásos módon konvertálja az R logikai értékre (0=FALSE, minden más érték=TRUE). Összetett logikai kifejezések is szerepelhetnek a feltételben, ezeket többnyire a &amp;&amp; és || logikai operátorokkal építjük fel. A korábban megismert elemenkénti művelet-végrehajtást támogató &amp; és | logikai operátorokhoz képest a &amp;&amp; és || operátorok mindig egyetlen logikai értékkel térnek vissza: c(T,F) &amp; c(F,T) ## [1] FALSE FALSE c(T,F) &amp;&amp; c(F,T) ## [1] FALSE A &amp;&amp; és || operátorok támogatják a rövidzár végrehajtást, vagyis csak akkor értékelik ki a második argumentumot ha az szükséges: x&lt;-0 1 || (x&lt;-1) ## [1] TRUE x ## [1] 0 1 &amp;&amp; (x&lt;-1) ## [1] TRUE x ## [1] 1 A feltételes utasítás rövidebb formájában a teljes else részt elhagyhatjuk: if (feltétel) utasítás1 A feltételes utasításokat egymásba is ágyazhatjuk a következő formában: if (feltétel1) utasítás1 else if (feltétel2) utasítás2 else if (feltétel3) utasítás3 . . . else if (feltételn-1) utasításn-1 else utasításn Ezen túl, a feltételes utasításnak egy ifelse() nevű függvényváltozata is létezik. A függvény három argumentuma (test=, yes=, no=) megfelel az if utasítás feltétel, utasítás1, és utasítás2 részeinek, azzal az engedmény, hogy a vektorizált végrehajtás is megengedett: x &lt;- 1:10 ifelse(x&lt;=5,&quot;yes&quot;,&quot;no&quot;) ## [1] &quot;yes&quot; &quot;yes&quot; &quot;yes&quot; &quot;yes&quot; &quot;yes&quot; &quot;no&quot; &quot;no&quot; &quot;no&quot; ## [9] &quot;no&quot; &quot;no&quot; Többszörös feltételvizsgálatra a switch() függvényt is használhatjuk. switch(2,elso=10,masodik=20,harmadik=30) ## [1] 20 switch(&quot;elso&quot;,elso=10,masodik=20,harmadik=30) ## [1] 10 A switch() első paramétere egy numerikus vagy karakteres skalár, amely segítségével a többi paraméterből választhatunk visszatérési értéket. "],
["ciklus-utasitasok.html", "8.3 Ciklus utasítások", " 8.3 Ciklus utasítások Utasítások többszöri végrehajtására három vezérlőutasítást biztosít az R: for, while és repeat. A ciklusutasításokban felhasználhatjuk a next és a break kulcsszavakat. A for utasítás szintaxisa a következő: for (változó in vektor) utasítás A vektor lehet vektor vagy lista, a változó pedig rendre felveszi ennek az elemeit. Minden lépésben az utasítás is végrehajtásra kerül. Annyiszor hajtjuk végre az utasítás részt, ahány eleme van a vektor objektumnak. for(x in 1:5) print(x) ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 x ## [1] 5 A for mellékhatása, hogy a változó objektuma az utasítás végrehajtása után is elérhető, értéke pedig a vektor utolsó elemének az értéke lesz. A while utasítás szintaxisa a következő: while (feltétel) utasítás A while utasítás végrehajtása a feltétel kiértékelésével kezdődik, amely ha igaz, az utasítás rész is kiértékelésre kerül. Ezt a feltétel újbóli kiértékelése követi, és az utasítás mindaddig kiértékelésre kerül, míg egyszer már a feltétel hamissá válik. A while utasítás értéke az utolsó ciklusban kiértékelt utasítás értéke lesz. Ha a feltétel rögtön az első esetben hamis, vagyis az utasítás egyszer sem hajtódik végre, akkor a while utasítás NULL értéket szolgáltat. x&lt;-1 while (x&lt;=5) { print(x); x&lt;-x+1 } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 x ## [1] 6 A repeat utasítás szintaxisa a következő: repeat utasítás A repeat az utasítás folyamatos ismétlését végzi. Ha el akarjuk kerülni a végtelen ciklust, akkor gondoskodnunk kell a kilépésről. Ezt az utasításban szereplő feltételvizsgálat és break utasítás oldhatja meg, így a repeat utasítás része mindig egy blokk utasítás. x&lt;-1 repeat { print(x) x&lt;-x+1 if(x&gt;5) break } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 A break utasítás mindhárom ciklusban azonos jelentésű: a ciklusból lépünk ki. A next utasítás a ciklus újbóli végrehajtását kezdeményezhetjük. "],
["fuggveny-letrehozasa.html", "8.4 Függvény létrehozása", " 8.4 Függvény létrehozása Az R-ben saját függvényt a következő szintaktikával hozhatunk létre: függvénynév &lt;- function (argumentumlista) függvénytörzs Az argumentumlista formális argumentumok vesszővel elválasztott felsorolása, de akár el is hagyhatjuk. Egy formális argumentum állhat önmagában egy változónévből vagy egyenlőségjellel kapcsolhatunk hozzá kifejezést is, ekkor a kifejezés értéke lesz a formális argumentum alapértelmezett értéke. sajat.fuggveny &lt;- function(x,y) x+y sajat.fuggveny(1,2) ## [1] 3 A fenti példában az x és y formális argumentum nem rendelkezik alapértelmezett értékkel, a függvényhívás során mindkét argumentumról gondoskodnunk kell. sajat.fuggveny &lt;- function(x=0,y=0) x+y sajat.fuggveny() ## [1] 0 sajat.fuggveny(2) ## [1] 2 sajat.fuggveny(2,3) ## [1] 5 Most gondoskodtunk alapértelmezett értékről minkét argumentum számára, így 0, 1 vagy 2 aktuális paraméter megadásával is hívható a függvény. Az R-ben a ... (három pont) speciális formális argumentumot is használhatjuk, amely tetszőleges számú aktuális argumentum megadását lehetővé teszi a függvényhívás során. sajat.fuggveny &lt;- function(x, ...) sum(x, ...) sajat.fuggveny(1) ## [1] 1 sajat.fuggveny(1,2) ## [1] 3 sajat.fuggveny(1,2,3) ## [1] 6 sajat.fuggveny(1,2,3,4) ## [1] 10 A fenti függvény két formális argumentuma az x= és a ... (három pont), amely egyedül a paraméter nélküli hívást nem teszi lehetővé, egyébként tetszőleges számú aktuális argumentummal hívhatjuk. A fenti példákban nagyon egyszerű függvénytörzseket láttunk, lényegében egyetlen utasításból álltak. A tipikus azonban az, hogy a függvények törzse egy blokkutasítás, így több utasítást foghatunk össze. "],
["eleresi-ut.html", "8.5 Elérési út", " 8.5 Elérési út Az R az elérési útban (search path) tárolja az környezetek listáját. Ha egy változóra hivatkozunk, akkor az elérési útban felsorolt környezetekben keresi végig a nevet. Az első a globális környezet az utolsó a ”package:base” környezet. Az elérési út környezetei általában csomagok ill. a felhasználói adatai lehetnek. Ezek alól a globális környezet és az Autoloads környezet kivétel. Az elérési útba az attach() és a library() függvényekkel szúrhatunk be újat, és a detach() függvénnyel törölhetünk belőle. "],
["hataskor.html", "8.6 Hatáskör", " 8.6 Hatáskör Az R lexikális hatáskört használ. A globális környezet a munkaterület kiinduló pontja. A parancssor értékadó operátorai a globális környezetben hoznak létre objektumokat. Az globális környezetet az elérési útban a következő környezet határolja és így tovább, az üres környezetig, amely a base környezet foglalja magába. Egy függvényhívás során a függvény lokális változóit keret-nek (frame) nevezzük. A keret az ő környezetével együtt egy új környezetet hoz létre. A függvény definiálása során tekintett környezet a függvényhez tartozik. x&lt;-1 f&lt;-function(x) { x&lt;-x+2;x&lt;&lt;-10;cat(&quot;f.1: x=&quot;, x,&quot;\\n&quot;,sep=&quot;&quot;); g&lt;-function(x) {x+2; x&lt;&lt;-100; x}; g(200); x } f(2) ## f.1: x=4 ## [1] 100 x ## [1] 10 "],
["feladatok-megoldasa.html", "9 Feladatok megoldása", " 9 Feladatok megoldása Hamarosan… ;) "]
]
